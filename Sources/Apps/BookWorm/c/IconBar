
/*
:HISTORY
:END

:MESSAGES
HdCH:This dialogue box lets you configure the appearance of the browser.
HdCH0:\Sapply your choices.
HdCH1:\Scancel your choices.
HdCH2:\Sapply your choices and save them to disc for future usage.
HdCH3:\Sreset the choices to their defaults.
HdCH4:\Schoose whether the URL entry toolbar is displayed at the top of the main browser \w.
HdCH5:\Schoose whether the toolbar with the navigation buttons is displayed at the top of the main browser \w.
HdCH6:\Schoose whether the status bar is displayed at the bottom of the main browser \w.
HdCH7:\Schoose whether images are loaded automatically, or only when the "Load images" button is pressed.
HdCH8:\Schoose whether the browser displays background images. Turning this off will make pages less "pretty", but speed up loading and screen refresh.
HdCHd:\Schoose which font to use for body text.
HdCHg:\Schoose which font to use for headings.
HdCHj:\Schoose which font to use for fixed-space (typewriter-like) text.
HdCHk:\Sbring up the network configuration dialogue box.
HdLOGIN:This dialogue lets you login and use the World Wide Web.
HdLOGIN0:Click SELECT to login and use the World Wide Web.
HdLOGIN1:Click SELECT to cancel the login.
HdLOGIN2:Enter your assigned user name in this field.
HdLOGIN3:Enter your password in this field.
HdPO:This dialogue box lets you describe your network setup
HdPO2:Drag your !PostIn directory into this icon to set the path
HdPO3:Drag your !PostOut directory into this icon to set the path
HdPOd:Click SELECT to disable proxy services
HdPO7:Click SELECT if your proxy server is on this computer
HdPOa:Click SELECT to use the machine exporting the named disc as a proxy (you can drag a disc icon to the dialogue box to select it)
HdPOb:Click SELECT to use the indicated IP address as a proxy server
HdPO9:Click SELECT to use the indicated AUN station as a proxy
HdPOc:Enter the identifier (name or IP address) of your proxy server in this field
HdPO0:Click SELECT to close this dialogue box.
HdPO1:Click SELECT to cancel any changes you have made.
:END
*/

#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "ctype.h"
#include "time.h"

#include "kernel.h"
#include "swis.h"
#include "msgs.h"
#include "res.h"
#include "dbox.h"
#include "wimp.h"
#include "wimpt.h"
#include "help.h"
#include "xferrecv.h"
#include "werr.h"
#include "saveas.h"
#include "bbc.h"
#include "event.h"
#include "visdelay.h"
#include "akbd.h"
#include "coords.h"
#include "win.h"

/*-----------------------------------------------------------------*/
#include "menu.h"

#include "ErrorGen.h"
#include "PlotSpr.h"
#include "MenuDefs.h"
#include "Bone.h"
#include "Main.h"
#include "Browser.h"
#include "Button.h"
#include "Hotlist.h"
#include "FontManage.h"
#include "Redraw1.h"
#include "Defs.h"
#include "Iconbar.h"
#include "URLv.h"
#include "FindProxy.h"
#include "Forms.h"
#include "Printing.h"

#if 0
/*-----------------------------------------------------------------*/
typedef struct paramdef { /* ;p search for ;p to find parameter related bits */
  char   homepage[256];
  BOOL   systemfont; /* use system font for everything */
  int    maxvhistory; /* max entries in per-view history list */
  int    maxghistory; /* max size of global history (kbytes) */
  int    maxhot; /* max entries in hotlist */
  int    fontsize; /* basic font size, 16ths of a point */
  char   historyfile[256]; /* default pathname to store global visit history */
  char   hotlistfile[256]; /* default pathname to store hot list */
  BOOL   urlbar;
  BOOL   toolbar;
  BOOL   statusbar;
  BOOL   delayimages;
  BOOL   maximages;
  int    col_back;
  int    col_text;
  int    col_link;
  int    col_used;
  char   username[20];
  char   password[11];
  char   fixedptr; /* the pointer must not change shape */
  char   proxy[64];
  char   post_in[256];
  char   post_out[256];
  BOOL   displaybgs;
} paramdef;

/*-----------------------------------------------------------------*/
typedef struct userdef { /* user info */
  char   homepage[256];
  char   name[32];
  char   lastfind[64]; /* last search string. stored here so its automatically cleared on logout */
  BOOL   casematch; /* case match flag for searches. stored here so its automatically cleared on logout */
  char   historyfile[256]; /* users history file */
  char   hotlistfile[256];  /* users hot list file name */
} userdef;

/*-----------------------------------------------------------------*/
typedef void (*ml_param_processor) (char *command,char *param);

#endif

static char *proxytype="None    "
                       "Local   "
                       "Access  "
                       "AUN     "
                       "IP      ";


static void iconbar_shutdown(void);
static os_error *iconbar_netprefs(void);
#ifndef SINGLE_USER
static FILE *file_open_postbox(const char *where, char *name);
#endif

/*-----------------------------------------------------------------*/
userdef user;
/*-----------------------------------------------------------------*/
paramdef params;

#define ML_PARAMS_BUFFER_SIZE 4096

#define message_URLACTION 0x4AF80

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static char *ml_gstrans(char *pass)
{
os_regset regs;
char      junk[256];

regs.r[0]=(int)pass;
regs.r[1]=(int)junk;
regs.r[2]=255;
os_swix(XOS_Bit|OS_GSTrans,&regs);
if(regs.r[2]>255)
  junk[255]=0;
else
  junk[regs.r[2]]=0;
strcpy(pass,junk);
return(pass);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static int ml_expand(char *d,char **s,char *control,int flags)
{
char  digits[]="0123456789+-.";
int   flag;
int   done;
int   quotes;
int   anyquote;
char  *p;
char  *t;

p=*s;
t=d;
done=0;
flag=0;
quotes=0;
anyquote=0;
while(*p==32) p++;
if(strchr(digits,*p)) flag++;
while(*p && !done)
  {
  if(!quotes && strchr(control,*p))
    {
    done++;
    p++;
    }
  else
    {
    if(*p=='"') quotes^=1;
    *t++=*p++;
    }
  }
*s=p;
*t=0;
p=d;
if(flags&1)
  {
  if(*p=='"') p++;
  t=strchr(p,0);
  if(t>p && *(t-1)=='"') *(t-1)=0;
  strcpy(d,p);
  }
return(flag);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static char *ml_strip(char *pass)
{
char *j;
char *k;

j=pass-1;
while(*++j==32);
k=j-1;
while(*++k!=0);
while(*--k==32 && k>=pass) *k=0;
return(strcpy(pass,j));
}

static char *ml_charcat(char *pass,char ch)
{
char *p;
p=strchr(pass,0);
*p++=ch;
*p=0;
return(pass);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static char *ml_strupr(char *s)
{
  char *t=s;

  for(;*s;s++)
    *s=(char)toupper((int)*s);
  return t;
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static int ml_params_tag(char *tag,char *tags[])
{
int  result;
int  loop;
char ltag[100];

result=-1;
loop=0;
strcpy(ltag,tag);
ml_strupr(ltag);
while(*tags[loop])
  {
  if(!strcmp(ltag,tags[loop])) result=loop;
  loop++;
  }
return(result);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static BOOL ml_params_switch(char *param)
{
char junk[256];
char j2[256];
int  result;

result=0;
ml_strupr(strcpy(junk+1,param));
ml_strupr(strcpy(j2,msgs_lookup(
  "ml_truths:,On,True,Chalk,Yes,I,Oui,One,Si,Ja,Y,J,Go,Good,Ok,High,")));
if(isdigit(junk[1]))
  {
  if(atoi(junk+1)) result=TRUE;
  }
else
  {
  ml_charcat(junk+1,',');
  *junk=',';
  if(strstr(j2,junk)) result=TRUE;
  }
return(result);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static int ml_params_readln(FILE *file,char *buffer,int pos,char *line)
{
char *p;

p=line;
*p=13;
while(*p)
  {
  if(pos>=ML_PARAMS_BUFFER_SIZE)
    {
    memset(buffer,0,ML_PARAMS_BUFFER_SIZE);
    fread(buffer,1,ML_PARAMS_BUFFER_SIZE,file);
    pos=0;
    }
  *p=buffer[pos++];
  if(*p==13)
    {
    if(pos>=ML_PARAMS_BUFFER_SIZE)
      {
      memset(buffer,0,ML_PARAMS_BUFFER_SIZE);
      fread(buffer,1,ML_PARAMS_BUFFER_SIZE,file);
      pos=0;
      }
    *p=buffer[pos++];
    if(*p!=10)
      {
      *p=10;
      pos--;
      }
    }
  if(*p)
    {
    if(*p==10)
      *p=0;
    else
      {
      if((int)p<(int)(line+255)) p++;
      *p=13;
      }
    }
  else
    pos=-1;
  }
return(pos);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static void ml_params_read(ml_param_processor process_param)
{
FILE *parmfile;
char file_buffer [ML_PARAMS_BUFFER_SIZE];
char line        [256];
char junk        [256];
char *tag;
char *param;
int  buffer_pos,enddone;
char *s;

enddone=0;
buffer_pos=ML_PARAMS_BUFFER_SIZE+1;
parmfile=res_openfile("PARAMS","r+");
if(parmfile)
  {
  while(buffer_pos!=-1)
    {
    buffer_pos=ml_params_readln(parmfile,file_buffer,buffer_pos,line);
    ml_strip(line);
    if(*line && *line!='#' && *line!=';')
      {
      tag=line;
      s=line;
      while(*s && *s!=32) s++;
      param=s;
      while(*param==32) param++;
      *s=0;
      ml_strupr(tag);
      while(*param)
        {
        ml_expand(junk,&param,", ",1);
        ml_gstrans(junk);
        process_param(tag,junk);
        if(!strcmp(tag,"END"))
          {
          buffer_pos=-1;
          enddone++;
          }
        }
      }
    }
  if(!enddone) process_param("END"," ");
  fclose(parmfile);
  }
}

extern char *inet_ntoa(struct in_addr);

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static os_error *iconbar_setproxy(void)
{ /* set the proxy, return error or NULL if OK */
  os_error *e=NULL;
  char buffer[256], *stype, *text;
  int type;
  char addr[256], *p;
  struct in_addr in;

  strcpy(buffer, params.proxy);
  stype=strtok(buffer, ";"); if (stype==0) stype="None";
  text=strtok(NULL, ";");
  if (text==NULL)
    text="";

  p=strstr(proxytype, stype);
  if (p)
      type=(p-proxytype)/8;
  else
      type=0;

  switch (type)
  {
    case 0: /* None */
      addr[0]='\0';
      break;

    case 1: /* Local */
      strcpy(addr, "http://127.0.0.1/");
      break;

    case 2: /* Access */
      in=find_share(text);
      if (in.s_addr == 0)
          return errorgen(14);
      sprintf(addr, "http://%s/", inet_ntoa(in));
      break;

    case 3: /* AUN */
      in=find_station(text);
      if (in.s_addr == 0)
        return errorgen(15);
      sprintf(addr, "http://%s/", inet_ntoa(in));
      break;

    case 4: /* IP */
      sprintf(addr, "http://%s/", text);
      break;
  }

  /* We only do HTTP proxies for now */

  /* Remove all proxies */
  url_set_proxy(0,0,0,0,0);

  if (addr[0]) {
      e=(os_error*)url_set_proxy(0,0,addr,"http:",0);
      e=(os_error*)url_set_proxy(0,0,addr,"ftp:",0);
  }

  if(e)
    {
      e=errorgen((int)e);
      wimpt_complain(e); /*;{{ */
      url_set_proxy(0,0,addr,"",1);
      strcpy(params.proxy,"None;");
      return(e);
    }
  return(NULL);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static void read_program_defaults(char *command,char *param)
{
  BOOL sw=FALSE;
  char *tests[]=
  {
    "BUTTON",
    "HOMEPAGE",
    "SYSTEMFONT",
    "VHISTSIZE",
    "GHISTSIZE",
    "MAXHOTLIST",
    "FONT",
    "FONTSIZE",
    "HISTORY",
    "HOTLIST",
    "TOOLBAR",
    "URLBAR",
    "STATUSBAR",
    "DELAYIMAGES",
    "MAXIMAGES",
    "PAGECOLOUR",
    "TEXTCOLOUR",
    "LINKCOLOUR",
    "USEDCOLOUR",
    "USER",
    "PASSWORD",
    "FIXEDPOINTER",
    "PROXY",
    "POSTIN",
    "POSTOUT",
    "DISPLAYBGS",
    "END",
    ""
  }; /* ;p */

  sw=ml_params_switch(param);
  switch(ml_params_tag(command,tests))
  {
    case 0: break;
    case 1:STRFILL(params.homepage,param); break;
    case 2:params.systemfont=sw; break;
    case 3:params.maxvhistory=strtoul(param,NULL,0); break;
    case 4:params.maxghistory=strtoul(param,NULL,0); break;
    case 5:params.maxhot=strtoul(param,NULL,0); break;
    case 6:wimpt_complain(fm_define_typeface(param)); break;
    case 7:params.fontsize=strtoul(param,NULL,0); break;
    case 8:STRFILL(params.historyfile,param); break;
    case 9:STRFILL(params.hotlistfile,param); break;
    case 10:params.toolbar=sw; break;
    case 11:params.urlbar=sw; break;
    case 12:params.statusbar=sw; break;
    case 13:params.delayimages=sw; break;
    case 14:params.maximages=strtoul(param,NULL,0); break;
    case 15:params.col_back=strtoul(param,NULL,0)&0xffffff00; break;
    case 16:params.col_text=strtoul(param,NULL,0)&0xffffff00; break;
    case 17:params.col_link=strtoul(param,NULL,0)&0xffffff00; break;
    case 18:params.col_used=strtoul(param,NULL,0)&0xffffff00; break;
    case 19:STRFILL(params.username,param); break;
    case 20:STRFILL(params.password,param); break;
    case 21:params.fixedptr=sw; break;
    case 22:STRFILL(params.proxy,param); break;
    case 23:STRFILL(params.post_in,param); break;
    case 24:STRFILL(params.post_out,param); break;
    case 25:params.displaybgs=sw; break;
  } /* ;p */
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static BOOL fyn(FILE *f,char *s,BOOL yn)
{
return(fprintf(f,"%-15s %s\n",s,(yn?"Yes":"No"))<0);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static os_error *validate_params(void)
{ /* ;p */
  if(params.maxvhistory<10) params.maxvhistory=10;
  if(params.maxghistory<1) params.maxghistory=1;
  if(params.maxhot<10) params.maxhot=10;
  if(params.fontsize<75) params.fontsize=75;
  if(params.fontsize>1600) params.fontsize=1600;
  if(!params.historyfile[0]) sprintf(params.historyfile,"<%s$Dir>.User.History",progname+1);
  if(!params.hotlistfile[0]) sprintf(params.hotlistfile,"<%s$Dir>.User.HotList",progname+1);
  if(params.maximages<1) params.maximages=1; else if(params.maximages>32) params.maximages=32;
  if(params.col_back==params.col_text || (params.col_back&1)) params.col_back=0xdddddd00;
  if(params.col_back==params.col_text || (params.col_text&1)) params.col_text=0;
  if(params.col_back==params.col_link || (params.col_link&1)) params.col_link=0x99440000;
  if(params.col_back==params.col_link) params.col_link=0;
  if(params.col_back==params.col_used || (params.col_used&1)) params.col_used=0x9944bb00;
  if(params.col_back==params.col_used) params.col_used=0;
  iconbar_setproxy();
  return(NULL);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/*
 * Try to twiddle the params file. Read-only files can be opened up, but
 * not written to. Files on a read-only filing system cannot be opened up.
 * Beware!
 */
static BOOL have_write_access()
{
    static int checked=-1;
    char filename[256];
    BOOL writeable=FALSE;
    os_regset r;
    os_error *e;
    int f;
    int b;

    if (checked!=-1)
        return (BOOL) checked;

    res_findname("Params", filename);

    /* Open file read/write */
    r.r[0]=0xC0; r.r[1]=(int) filename;
    e=os_find(&r);

    if (!e && (f=r.r[0])!=0)
    {
        /* Read first byte */
        r.r[1]=f;
        os_swix(OS_BGet, &r);
        b=r.r[0];

        /* Reset file pointer to 0 */
        r.r[0]=1; r.r[1]=f; r.r[2]=0;
        os_args(&r);

        /* Write first byte */
        r.r[0]=0; r.r[1]=f;
        e=os_swix(OS_BPut, &r);
        if (!e)
        {
            /* If we managed to write first byte */
            writeable=TRUE;
            /* Reset file pointer to 0 */
            r.r[0]=1; r.r[1]=f; r.r[2]=0;
            os_args(&r);

            /* Write first byte */
            r.r[0]=b; r.r[1]=f;
            os_swix(OS_BPut, &r);
        }
        /* Close file */
        r.r[0]=0; r.r[1]=f;
        e=os_find(&r);
        if (e)
            writeable=FALSE;
    }

    checked=writeable;
    return writeable;
}

/*----------------------------------------------------------------------*/
void loadprefs(void)
{
  memset(&params,0,sizeof(params));
  params.col_back=params.col_text=params.col_link=params.col_used=1;
  ml_params_read(read_program_defaults);
  validate_params();
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static os_error *saveprefs(void)
{ /* ;p */
FILE     *stream;
char     fname[512];
BOOL     err=FALSE;
os_error *oe=NULL;

res_findname("Params",fname);
stream=fopen(fname,"w");
if(!stream) oe=errorgen((int)_kernel_last_oserror());
if(!oe && fprintf(stream,
                  "; Parameter file\n"
                  ";\n"
                  "; Entries are:\n"
                  ";\n"
                  "; HomePage        <URL>    Default URL of home page\n"
                  "; SystemFont      <Y/N>    Whether to try and display using system font\n"
                  "; VHistSize       <number> Max entries in view history list\n"
                  "; GHistSize       <number> Max size of global history (kbytes)\n"
                  "; MaxHotlist      <number> Max entries in user hotlist\n"
                  "; History         <path>   Default file to store the global visit history\n"
                  "; HotList         <path>   Default file to store the hotlist\n"
                  "; FontSize        <number> Base font size, 16ths of a point\n"
                  "; Font            <desc>   Define font - repeat as necessary\n"
                  "; Toolbar         <Y/N>    Whether to display the toolbar by default\n"
                  "; URLBar          <Y/N>    Whether to display the URL bar by default\n"
                  "; StatusBar       <Y/N>    Whether to display the status bar by default\n"
                  "; DelayImages     <Y/N>    Whether to delay the loading of images\n"
                  "; DisplayBGs      <Y/N>    Whether to display page backgrounds\n"
                  "; MaxImages       <number> Maximum number of images to fetch simultaneously\n"
                  "; PageColour      <number> Colour word for default page background colour\n"
                  "; TextColour      <number> Colour word for default text colour\n"
                  "; LinkColour      <number> Colour word for default link text colour\n"
                  "; UsedColour      <number> Colour word for default followed link text colour\n"
                  "; FixedPointer    <Y/N>    Set to Y to prevent changing the pointer shape\n"
                  "; Proxy           <url>    Proxy, as set in the network configuration dbox\n"
                  "; PostIn          <path>   Path to PostIn directory\n"
                  "; PostOut         <path>   Path to PostOut directory\n"
                  ";\n"
                  "\n")<0)
  oe=errorgen((int)_kernel_last_oserror());
if(oe) err=TRUE;
if(!err) err=fprintf(stream,"HomePage        %s\n",params.homepage)<0;
if(!err) err=fyn(stream,"SystemFont",params.systemfont);
if(!err) err=fprintf(stream,"VHistSize       %d\n",params.maxvhistory)<0;
if(!err) err=fprintf(stream,"GHistSize       %d\n",params.maxghistory)<0;
if(!err) err=fprintf(stream,"MaxHotlist      %d\n",params.maxhot)<0;
if(!err) err=fprintf(stream,"History         %s\n",params.historyfile)<0;
if(!err) err=fprintf(stream,"HotList         %s\n",params.hotlistfile)<0;
if(!err) err=fprintf(stream,"FontSize        %d\n",params.fontsize)<0;
if(!err) {oe=fm_write_descriptor("sans",fname); if(!oe) err=fprintf(stream,"Font            %s\n",fname)<0; else err=TRUE;}
if(!err) {oe=fm_write_descriptor("serif",fname); if(!oe) err=fprintf(stream,"Font            %s\n",fname)<0; else err=TRUE;}
if(!err) {oe=fm_write_descriptor("fixed",fname); if(!oe) err=fprintf(stream,"Font            %s\n",fname)<0; else err=TRUE;}
if(!err) {oe=fm_write_descriptor("system",fname); if(!oe) err=fprintf(stream,"Font            %s\n",fname)<0; else err=TRUE;}
if(!err) {oe=fm_write_descriptor("dialogue",fname); if(!oe) err=fprintf(stream,"Font            %s\n",fname)<0; else err=TRUE;}
if(!err) err=fyn(stream,"Toolbar",params.toolbar);
if(!err) err=fyn(stream,"URLBar",params.urlbar);
if(!err) err=fyn(stream,"StatusBar",params.statusbar);
if(!err) err=fyn(stream,"DelayImages",params.delayimages);
if(!err) err=fyn(stream,"DisplayBGs",params.displaybgs);
if(!err) err=fprintf(stream,"MaxImages       %d\n",params.maximages)<0;
if(!err) err=fprintf(stream,"PageColour      0x%08x\n",params.col_back)<0;
if(!err) err=fprintf(stream,"TextColour      0x%08x\n",params.col_text)<0;
if(!err) err=fprintf(stream,"LinkColour      0x%08x\n",params.col_link)<0;
if(!err) err=fprintf(stream,"UsedColour      0x%08x\n",params.col_used)<0;
 if(!err) err=fyn(stream,"FixedPointer",params.fixedptr);
if(!err && params.proxy[0]) err=fprintf(stream,"Proxy           %s\n",params.proxy)<0;
if(!err && params.post_in[0]) err=fprintf(stream,"PostIn          %s\n",params.post_in)<0;
if(!err && params.post_out[0]) err=fprintf(stream,"PostOut         %s\n",params.post_out)<0;
if(!err && !oe) err=fprintf(stream,"END\n")<0;
fclose(stream);
if(err && !oe) oe=errorgen((int)_kernel_last_oserror());
return(oe);
}

/*----------------------------------------------------------------------*/
int global_fixed_ptr(void)
{
  return(params.fixedptr);
}

/*----------------------------------------------------------------------*/
os_error *iconbar_logout(void)
{
    return NULL; /* a dummy - remove all references please ;{{ */
}

static os_error *iconbar_really_logout(void)
{
  #ifdef SINGLE_USER
  hotlist_make_file(FALSE,0,user.hotlistfile,0);
  browser_save_history();
  #else
  FILE *f;
  char buf[256], name[256];
  sprintf(buf,"%s.PostBoxes",params.post_out);
  f=file_open_postbox(buf, name);
  if (f==0)
      wimpt_complain(errorgen(7));
  else
  {
      sprintf(buf, "X-Mercury-Command:SaveHotlist\n%s\n", user.name);
      /* Yuckery - we hope that the new naming scheme should prevent
         clashes. */
      fclose(f);
      hotlist_make_file(FALSE, 0, name, buf);
  }
  #endif
  browser_lose_history();
  memset(&user,0,sizeof(user));
  return(NULL);
}

#ifndef SINGLE_USER
static BOOL file_write_line(FILE *f, const char *s, BOOL newline)
{
    fputs(s, f);
    if (newline)
        fputc('\n', f);

    return !ferror(f);
}

static BOOL file_get_line(FILE *f, char *buf, BOOL unknown)
{
    char *p;

    p=fgets(buf, 256, f);

    if (!p)
        return FALSE;

    while (*p != '\n' && *p != '\0')
        p++;

    *p='\0';

    return TRUE;
}

static unsigned file_get_stamp(const char *f)
{
    unsigned exec_addr;

    _swix(OS_File, _INR(0,1)|_OUT(3), 23, f, &exec_addr);

    return exec_addr;
}

static unsigned file_get_length(const char *f)
{
    unsigned len;
    int type;

    _swix(OS_File, _INR(0,1)|_OUT(0)|_OUT(4), 23, f, &type, &len);
    if (type==0)
        return 0;

    return len;
}

BOOL file_exists(const char *f)
{
    int type;

    _swix(OS_File, _INR(0,1)|_OUT(0), 23, f, &type);

    return (type!=0);
}

static int pass_pos;
static char current_pass[256];
static char login_pb[256];

static void encode_line(char *buf,int keepnl,int magic)
{
 int i,len;
 char p;
 char *password=current_pass;

 len=strlen(buf);
 buf[len]='\n';
 buf[len+1]=0;

 for (i=0;i<=len;i++)
 {
  p=password[pass_pos];
  if ( (!keepnl) || ((buf[i]!='\n') && ((buf[i]^p)!='\n')))
  {
   if ((buf[i]!=p) && (buf[i] !=0))
      buf[i]^=p;
  }
  pass_pos++;
  if (password[pass_pos]<32)
  {
   unsigned int r1,r2,tmp;
   if (magic)
   {
    sscanf(password,"%8x%8x",&r1,&r2);
    tmp = r2 &  1;
    r2  = r2 >> 1;
    if (r1 & 1) r2 |= (1U<<31);
    r1  = r1 >> 1;
    if (tmp) r1 |= (1U<<31);
    sprintf(password,"%08x%08x",r1,r2);
   }
   pass_pos=0;
  }
 }
}


static void decode_data(char *data,int len,char *pass,int keepnl,int magic)
{
 int i;
 char *c;
 char p;
 char password[256];

 strcpy(password,pass);

 /* Now decode the data */
 c=data;
 i=0;
 while (c<data+len)
 {
  p=password[i];
  if ((!keepnl) || ((*c!='\n') && (((*c)^p)!='\n')))
  {
   if ((*c!=0) && (*c!=p)) *c=(*c)^p;
  }
  i++;
  if (password[i]<32)
  {
   unsigned int r1,r2,tmp;
   if (magic)
   {
    sscanf(password,"%8x%8x",&r1,&r2);
    tmp = r2 &  1;
    r2  = r2 >> 1;
    if (r1 & 1) r2 |= (1U<<31);
    r1  = r1 >> 1;
    if (tmp) r1 |= (1U<<31);
    sprintf(password,"%08x%08x",r1,r2);
   }
   i=0;
  }
  c++;
 }
}

static char trans_file[9];

void file_create_unique_post_box_file_name(void)
{
    char *tmp;
    tmp = getenv("Inet$LocalAddr"); /* if Inet$LocalAddr exists use it as the filename  */
    if (tmp)
    {
        strncpy(trans_file, tmp, 8);
        trans_file[8]='\0';
    }
    else
    {
        unsigned t;
        _swix(OS_ReadMonotonicTime, _OUT(0), &t);
        srand(t);
        sprintf(trans_file, "%x", rand());
    }
}

static FILE *file_open_postbox(const char *where, char *name)
{
    char buf[3];
    int count=0, tmp2;

    sprintf(name, "%s.%s", where, trans_file);

    tmp2 = strlen(name);

    while(file_exists(name))
    	{
    	*(name+tmp2) = '\0';
    	sprintf(buf, "%02i", count++);
    	strcat(name, buf);
    	if (count > 70)
    		return (0);
    	}

    return fopen(name, "w");
}

#endif


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* Verify user name and password */

BOOL logged_in=FALSE;
BOOL re_login=FALSE;
#ifndef SINGLE_USER
static unsigned login_stamp;
static time_t login_time;
static char login_password[12];
static char login_user[20];
static char rnd_buf[20], rnd_buf1[20];

os_error *iconbar_read_user(const char *user, const char *password)
{
 char pass[12];
 FILE *f;
 unsigned int rnd,rnd1;
 char *c;
 char rnd_buf2[64], rnd_buf3[64], buf[64];

 srand(time(NULL));
 rnd=rand();
 rnd1=rand();
 sprintf(rnd_buf,"%08x%08x",rnd,rnd1);
 strcpy(rnd_buf2,rnd_buf);
 rnd=rand();
 rnd1=rand();
 sprintf(rnd_buf1,"%08x%08x",rnd,rnd1);
 strcpy(rnd_buf3,rnd_buf1);

 if (user[0]==0 || password[0]==0)
     return errorgen(4);

 strcpy(pass, password);

 sprintf(buf,"%s.PostBoxes",params.post_out);
 f=file_open_postbox(buf,login_pb);   /* Create a postbox file */

 if (f==0)
     return errorgen(7);    /* No postboxes available */

 for (c=pass;*c;c++)
    *c=tolower(*c);  /* Ignore password case */

 pass_pos=0;
 strcpy(current_pass,pass);
 encode_line(rnd_buf2,TRUE,FALSE);
 pass_pos=0;
 strcpy(current_pass,rnd_buf);
 encode_line(rnd_buf3,TRUE,TRUE);

 /* Now we have a postbox */
 if ( file_write_line(f,"X-Mercury-Command:Login200\n",FALSE) &&
      file_write_line(f,user,TRUE)                            &&
      file_write_line(f,rnd_buf2,FALSE)                       &&
      file_write_line(f,rnd_buf3,FALSE)                       &&
      file_write_line(f,"WWWAccess\n",FALSE)
    )
    {
     login_time=time(NULL);                  /* For timeout */
     strcpy(login_password,pass);
     strcpy(login_user,user);
    }
    else
     wimpt_complain(errorgen(8));  /* Error wirting to postbox */

 fclose(f);

 login_stamp=file_get_stamp(login_pb);       /* Watch for server writing to file */

 return NULL;
}

win_event_handler old_iconbar_handler;
void *old_iconbar_handle;

/* Check login state, should be called on NULL events while
   waiting for login result */

void check_login(wimp_eventstr *e, void *h)
{
 char pass[256],key[256];
 char temp[256];
 char user_file[256];

 /* While we are waiting for login - don't do anything else */
 if (e->e != wimp_ENULL)
    return;

 if (file_get_length(login_pb)==0)
 {
  wimpt_complain(errorgen(9));          /* User name of password wrong */
  //win_register_event_handler(win_ICONBAR, 0, 0);
  //win_register_event_handler(win_ICONBAR, old_iconbar_handler, old_iconbar_handle);
  //idle_deregister_user(check_login, 0);
  re_login=TRUE;
  return;
 }

 if (file_get_stamp(login_pb)!=login_stamp) /* File modified */
 {
  FILE *f;
  f=fopen(login_pb, "r");

  if (f==NULL)   /* Server still writing to file ? */
  {
   time_t t=time(NULL);
   visdelay_begin();
   while (difftime(time(NULL),t)<5);         /* Wait up to 5 seconds */
   visdelay_end();
   f=fopen(login_pb, "r");                    /* And try again */
  }

  if (f)  /* File opened ? */
  {
   if ((file_get_line(f,temp,FALSE)==0) ||
       (file_get_line(f,user_file,FALSE)==0) ||
       (file_get_line(f,temp,FALSE)==0) ||
       (file_get_line(f,pass,FALSE)==0) ||
       (file_get_line(f,key,FALSE)==0))
   {
    wimpt_complain(errorgen(10));    /* Error reading from file or fake file */
    fclose(f);
    remove(login_pb);
    re_login=TRUE;
    return;
   }
   else if (strcmp(pass,rnd_buf) != 0)
   {
    wimpt_complain(errorgen(9));    /* Wrong username / password */
    fclose(f);
    remove(login_pb);
    re_login=TRUE;
    return;
   }
   else      /* File appears to be ok */
   {
      /* Check we are allowed WWWAccess */

      /* Read third line */
      if ( file_get_line(f,temp,FALSE)==0
           || file_get_line(f,temp,FALSE)==0
           || file_get_line(f,temp,FALSE)==0)
      {
          wimpt_complain(errorgen(10));  /* Error reading from file */
          fclose(f);
          remove(login_pb);
          re_login=TRUE;
          return;
      }
      if (strcmp(temp, "Yes")!=0)
      {
          wimpt_complain(errorgen(12)); /* Sorry, you are not authorised to access WWW */
          fclose(f);
          remove(login_pb);
          iconbar_shutdown();
          exit(0);
      }

    /* Logged in is ok */
    pass_pos=0;
    decode_data(key,strlen(key),rnd_buf1,TRUE,TRUE);
    strcpy(params.password,key);
   }

   fclose(f);
   remove(login_pb);
   STRFILL(user.name, login_user);
   STRFILL(user.homepage, params.homepage);
   sprintf(user.hotlistfile, "%s.Web.%s.HotList", params.post_in, user_file);
   sprintf(user.historyfile, "%s.Web.%s.History", params.post_in, user_file);
   hotlist_load(user.hotlistfile, 0);
   sprintf(temp, "%s.Web.Resources", params.post_in);
   hotlist_load(temp, 1);
   browser_load_history();
   logged_in=TRUE;
  }
 } else  /* File not modified */
 {

  if (difftime(time(NULL),login_time)<30) return;  /* Not timed out */
  remove(login_pb);
  wimpt_complain(errorgen(11));         /* Server not responding */
  re_login=TRUE;

 }
// win_register_event_handler(win_ICONBAR, old_iconbar_handler, old_iconbar_handle);
 //win_register_event_handler(win_ICONBAR, 0, 0);
 //idle_deregister_user(check_login, 0);
}
#else
static os_error *iconbar_read_user(const char *name, const char *password)
{
  STRFILL(user.name,name);
  if(!user.homepage[0]) STRFILL(user.homepage,params.homepage); /* default homepage */
  if(!user.hotlistfile[0]) STRFILL(user.hotlistfile,params.hotlistfile);
  if(!user.historyfile[0]) STRFILL(user.historyfile,params.historyfile);
  hotlist_load(user.hotlistfile,0);
  browser_load_history();
  return(NULL);
}
#endif

/*----------------------------------------------------------------------*/
os_error *iconbar_login(void)
{
#ifdef SINGLE_USER
  iconbar_read_user(params.username,params.password);
#else
  dbox d;
  char name[sizeof(user.name)];
  char password[32];
  int  f;
  BOOL first=TRUE;
  os_error *e;

  user.name[0]=0;
  STRFILL(name,params.username);
  STRFILL(password,params.password);
  if(iconbar_read_user(name,password)) /* if the user in the parameters is missing or invalid */
  {
    d=dbox_new("login");
    if(!d) return(errorgen(2));
    dbox_raw_eventhandler(d,help_dboxrawevents,"HdLOGIN");
    dbox_showstatic(d);
    do
    {
      dbox_setfield(d,2,name);
      dbox_setfield(d,3,"");
      f=dbox_fillin(d);
      first=FALSE;
      if(f==0)
      {
        dbox_getfield(d,2,name,sizeof(name));
        dbox_getfield(d,3,password,sizeof(password));
        e=wimpt_complain(iconbar_read_user(name,password));
      }
    } while(/*f!=dbox_CLOSE &&*/ ((f!=0 && f!=1) || (f==0 && e)));
    dbox_dispose(&d);
    if (f==1)
    {
        iconbar_shutdown();
        exit(0);
    }
  }
#endif
  return(NULL);
}

/*----------------------------------------------------------------------*/
os_error *iconbar_newview(char *url)
{
  return browser_new_view_f(url);
}

/*----------------------------------------------------------------------*/
void iconbar_click(wimp_i i)
{
  i=i;
  if (logged_in)
    wimpt_complain(iconbar_newview(user.homepage));
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static BOOL iconbar__mdataload(wimp_msgstr *ms,BOOL dataopen)
{
  wimp_msgdataload *dl;
  char             *filename;

  dl=&ms->data.dataload;
  if((dl->type==FILETYPE_TEXT && !dataopen) || dl->type==FILETYPE_HTML)
  { /* ;{{ temporary testbed for hotlist_load() */
    if(akbd_pollsh())
    {
      xferrecv_checkinsert(&filename);
      xferrecv_insertfileok();
      wimpt_complain(hotlist_load(filename,akbd_pollctl()?1:0));
      return(TRUE);
    }
    else
    {
      char url[300];

      xferrecv_checkinsert(&filename);
      xferrecv_insertfileok();
      STRFILL(url,filename);
      browser_pathname_to_url(url,sizeof(url));
      wimpt_complain(iconbar_newview(url));
    }
  }
  return(FALSE);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static void iconbar_shutdown(void)
{
  browser_stop_all_f(TRUE);
  browser_destroy_all_f();
  iconbar_really_logout();
  fm_destroy_typefaces();
  if(!global_fixed_ptr()) visdelay_end();
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static BOOL iconbar__esendwantack(wimp_eventstr *e)
{
switch (e->data.msg.hdr.action)
  {
    case wimp_MPREQUIT      : /* no break - through to MCLOSEDOWN */
    case wimp_MCLOSEDOWN    : iconbar_shutdown(); break;
    case wimp_MDATAOPEN     : return(iconbar__mdataload(&e->data.msg,TRUE)); break;
    case wimp_MDATALOAD     : return(iconbar__mdataload(&e->data.msg,FALSE)); break;
    case wimp_MMODECHANGE   : plotspr_invalidate_cache(); browser_mode_change(); break;
    case wimp_PALETTECHANGE :
      {
      plotspr_invalidate_cache();
      browser_update_all();
      } break;
    case wimp_MHELPREQUEST: return(help_process(e));
    case message_URLACTION  : if (strncmp(e->data.msg.data.chars, "mailto:", 7) == 0)
                                  break;
                              e->data.msg.hdr.your_ref = e->data.msg.hdr.my_ref;
                              wimp_sendmessage(wimp_EACK, &e->data.msg, e->data.msg.hdr.task);
                              iconbar_newview(e->data.msg.data.chars);
                              break;

    case Browser_Message_PrintError:
    {
      if (e->data.msg.hdr.size == 20)
      {
        /* RISC OS 2 printer manager's PrintBusy response */

        wimpt_complain(errorgen_tag("PrintBusy:The printer is currently busy."));        
      }
      else
      {
        /* RISC OS 3 general error response */

        wimpt_complain((os_error *) &e->data.msg.data);
      }
    }
    break;

    case Browser_Message_PrintTypeOdd:
    {
      wimp_msgstr ptk;

      if (e->data.msg.hdr.your_ref && e->data.msg.hdr.your_ref == printer_message_ref)
      {
        /* The printer manager sent PrintTypeOdd as a reply to this */
        /* task (not a broadcast), so go ahead and print.           */

        printer_message_ref = 0;

        /* Send PrintTypeKnown */

        ptk.hdr.size     = 20;
        ptk.hdr.your_ref = e->data.msg.hdr.my_ref;
        ptk.hdr.action   = (wimp_msgaction) Browser_Message_PrintTypeKnown;

        wimp_sendmessage(wimp_ESEND, &ptk, e->data.msg.hdr.task);

        print_print(NULL);
      }

// Commented out as the Alias$@PrintType_FF4 system variable does this job
// anyway, and if we don't claim this message then anything else which may
// have a better idea of what to do at least gets a chance to try.
//
// This currently doesn't work, incidentally; the conditions on the 'if'
// are wrong (printer_message_ref has probably been set to 0, but I never
// got the chance to properly debug this before removing it due to time
// constraints...).
//
//      else if (printer_message_ref && e->data.msg.data.datasave.type == 0xFF4)
//      {
//        /* If the printer doesn't understand PrintOut files, then */
//        /* it may be broken (!) / PostScript. So reply, and copy  */
//        /* the file to the printer device directly.               */
//
//        printer_message_ref = 0;
//
//        ptk.hdr.size     = 20;
//        ptk.hdr.your_ref = e->data.msg.hdr.my_ref;
//        ptk.hdr.action   = (wimp_msgaction) Browser_Message_PrintTypeKnown;
//
//        wimp_sendmessage(wimp_ESEND, &ptk, e->data.msg.hdr.task);
//
//        _swix(OS_FSControl,
//              _INR(0,3),
//
//              26,
//              e->data.msg.data.datasave.leaf,
//              "printer:",
//              2); /* Flags - 'Force' set, but no others. */
//      }
    }
    break;

    case wimp_MDATASAVEOK:
    {
      if (e->data.msg.hdr.your_ref == printer_message_ref)
      {
        wimp_msgstr dl;
        int         file_size;

        /* Print to a file in Printer$Temp, then send a */
        /* DataLoad to the printer manager.             */

        printer_message_ref = 0;

        print_print(e->data.msg.data.datasave.leaf);

        _swix(OS_File,
              _INR(0,1) | _OUT(4),

              23,
              e->data.msg.data.datasave.leaf,

              &file_size);

        dl.hdr.size     = 64;
        dl.hdr.your_ref = e->data.msg.hdr.my_ref;
        dl.hdr.action   = wimp_MDATALOAD;

        dl.data.dataload.w    = e->data.msg.data.datasave.w;
        dl.data.dataload.i    = e->data.msg.data.datasave.i;
        dl.data.dataload.size = file_size;
        dl.data.dataload.type = 0xFF4;

        _swix(OS_File,
              _INR(0,2),

              18,
              e->data.msg.data.datasave.leaf,
              0xFF4);

        strcpy(dl.data.dataload.name, e->data.msg.data.datasave.leaf);

        wimp_sendmessage(wimp_ESEND, &dl, e->data.msg.hdr.task);
      }
    }
    break;
  }
return(FALSE);
}

/*----------------------------------------------------------------------*/
void iconbar_event(wimp_eventstr *e, void *pHandle)
{
pHandle=pHandle;
switch(e->e)
  {
    case wimp_ESEND        : /* no break - through to wimp_ESENDWANTACK */
    case wimp_ESENDWANTACK : iconbar__esendwantack(e); break;
  }
}


/*----------------------------------------------------------------------*/
/*             Code to handle the Choices dialogue box                  */
/*----------------------------------------------------------------------*/
#define CH_SET 0
#define CH_CANCEL 1
#define CH_SAVE 2
#define CH_DEFAULT 3

#define CH_URL_BAR 4
#define CH_TOOLBAR 5
#define CH_STATUS_BAR 6
#define CH_DELAY_IMAGES 7
#define CH_DISPLAY_BGS 8

#define CH_FONT_BODY 12
#define CH_FONT_BODY_POPUP 13
#define CH_FONT_HEADINGS 15
#define CH_FONT_HEADINGS_POPUP 16
#define CH_FONT_FIXED 18
#define CH_FONT_FIXED_POPUP 19

#define CH_NETWORK_CONFIG 20

static struct {
    BOOL *value;
    wimp_i icon;
    BOOL dflt;
}
ch_buttons[] =
{
    { &params.urlbar, CH_URL_BAR, TRUE },
    { &params.toolbar, CH_TOOLBAR, TRUE },
    { &params.statusbar, CH_STATUS_BAR, TRUE },
    { &params.delayimages, CH_DELAY_IMAGES, FALSE },
    { &params.displaybgs, CH_DISPLAY_BGS, TRUE },
    { 0, 0, FALSE },
};

static wimp_w ChoicesW;
static wimp_menustr *font_menubuf;
static void *font_databuf;
static wimp_i font_item;

void choices_create(void);
static void choices_open(void);
static void reset_choices_window(void);
static void choices_event_handler(wimp_eventstr *e, void *handle);
static void choices_button_handler(wimp_bbits bbits, wimp_i icon);
static BOOL choices_menu_handler(wimp_eventstr *e, void *handle);

void choices_create(void)
{
    wimp_wind *wind;

    wind=template_syshandle("Choices");
    wimp_create_wind(wind, &ChoicesW);
    win_register_event_handler(ChoicesW, choices_event_handler, 0);
    win_add_unknown_event_processor(choices_menu_handler, 0);
}

static void choices_open(void)
{
    wimp_wstate ws;
    wimp_caretstr cs;
    reset_choices_window();

    wimp_set_icon_state(ChoicesW, CH_SAVE,
                        have_write_access() ? (wimp_iconflags) 0 : wimp_INOSELECT ,
                        wimp_INOSELECT);
    wimp_set_icon_state(ChoicesW, CH_NETWORK_CONFIG,
                        have_write_access() ? (wimp_iconflags) 0 : wimp_INOSELECT ,
                        wimp_INOSELECT);
    wimp_get_wind_state(ChoicesW, &ws);
    ws.o.behind = (wimp_w) -1;
    wimp_open_wind(&ws.o);

    cs.w=ChoicesW;
    cs.i=(wimp_i) -1;
    cs.x=cs.y=0;
    cs.height=(1<<25);
    cs.index=0;
    wimp_set_caret_pos(&cs);
}

static void set_default_choices(void)
{
    int i;
    wimp_icon is;

    for (i=0; ch_buttons[i].value; i++)
        wimp_set_icon_state(ChoicesW, ch_buttons[i].icon,
                            ch_buttons[i].dflt ? wimp_ISELECTED : (wimp_iconflags)0,
                            wimp_ISELECTED);

    wimp_get_icon_info(ChoicesW, CH_FONT_BODY, &is);
    strcpy(is.data.indirecttext.buffer, "Trinity.Medium");
    wimp_set_icon_state(ChoicesW, CH_FONT_BODY, (wimp_iconflags) 0, (wimp_iconflags) 0);
    wimp_get_icon_info(ChoicesW, CH_FONT_HEADINGS, &is);
    strcpy(is.data.indirecttext.buffer, "Homerton.Medium");
    wimp_set_icon_state(ChoicesW, CH_FONT_HEADINGS, (wimp_iconflags) 0, (wimp_iconflags) 0);
    wimp_get_icon_info(ChoicesW, CH_FONT_FIXED, &is);
    strcpy(is.data.indirecttext.buffer, "Corpus.Medium");
    wimp_set_icon_state(ChoicesW, CH_FONT_FIXED, (wimp_iconflags) 0, (wimp_iconflags) 0);
}

static void set_font_icon(const char *name, int icon)
{
    fm_typeface face;
    wimp_icon is;

    strcpy(face.name, name);
    fm_read_typeface(&face);
    wimp_get_icon_info(ChoicesW, icon, &is);
    strcpy(is.data.indirecttext.buffer, face.fontnames[0]);
    wimp_set_icon_state(ChoicesW, icon, (wimp_iconflags) 0, (wimp_iconflags) 0);
}

static void modified_font(char *orig, char *mod, char *buffer)
{
    char origname[128];
    os_error *e=NULL;
    BOOL found;
    char *p, *p2;
    char *lastdot;
    int f=-1;

    _swix(Font_FindField, _INR(1,2)|_OUTR(1,2), orig, 'F', &p, &found);

    if (!found)
    	p=orig;

    p2=origname;
    while (*p>32 && *p!='\\')
        *p2++=*p++;
    *p2='\0';

    lastdot=strrchr(origname, '.');

    p=strtok(mod, " ");

    while (p)
    {
        sprintf(buffer, "%s.%s", origname, p);
        e=(os_error*)_swix(Font_FindFont, _INR(1,5)|_OUT(0), buffer, 12*16, 12*16, 90, 90, &f);
        if (e==NULL)
            break;

        if (lastdot)
        {
            *lastdot='\0';
            sprintf(buffer, "%s.%s", origname, p);
            *lastdot='.';
            e=(os_error*)_swix(Font_FindFont, _INR(1,5)|_OUT(0), buffer, 12*16, 12*16, 90, 90, &f);
            if (e==NULL)
                break;
        }
        p=strtok(NULL, " ");
    }

    if (f>=0)
        _swix(Font_LoseFont, _IN(0), f);

    if (e)
        strcpy(buffer, orig);
}

static void read_font_icon(const char *name, int icon)
{
    fm_typeface face;
    wimp_icon is;

    wimp_get_icon_info(ChoicesW, icon, &is);
    strcpy(face.name, name);
    fm_read_typeface(&face);
    strcpy(face.fontnames[0], is.data.indirecttext.buffer);
    modified_font(face.fontnames[0], getenv("Font$Italic"), face.fontnames[1]);
    modified_font(face.fontnames[0], getenv("Font$Bold"), face.fontnames[2]);
    modified_font(face.fontnames[2], getenv("Font$Italic"), face.fontnames[3]);

    fm_define_typeface_explicit(&face);
}


static void reset_choices_window(void)
{
    int i;

    for (i=0; ch_buttons[i].value; i++)
        wimp_set_icon_state(ChoicesW, ch_buttons[i].icon,
                            *ch_buttons[i].value ? wimp_ISELECTED : (wimp_iconflags)0,
                            wimp_ISELECTED);

    set_font_icon("serif", CH_FONT_BODY);
    set_font_icon("sans", CH_FONT_HEADINGS);
    set_font_icon("fixed", CH_FONT_FIXED);
}

static void read_choices_window(void)
{
    int i;
    wimp_icon is;

    for (i=0; ch_buttons[i].value; i++) {
        wimp_get_icon_info(ChoicesW, ch_buttons[i].icon, &is);
        *ch_buttons[i].value = is.flags & wimp_ISELECTED ? TRUE : FALSE;
    }
    read_font_icon("serif", CH_FONT_BODY);
    read_font_icon("sans", CH_FONT_HEADINGS);
    read_font_icon("fixed", CH_FONT_FIXED);
    read_font_icon("system", CH_FONT_FIXED);
    browser_update_all_status_text();
    browser_reformat_all();
}

static void choices_event_handler(wimp_eventstr *e, void *handle)
{
    switch (e->e)
    {
      case wimp_EOPEN:
        wimp_open_wind(&e->data.o);
        break;
      case wimp_EBUT:
        choices_button_handler(e->data.but.m.bbits, e->data.but.m.i);
        break;
      case wimp_EKEY:
        switch (e->data.key.chcode)
        {
          case 13:
            choices_button_handler(wimp_BLEFT, CH_SET);
            break;
          case 27:
            choices_button_handler(wimp_BLEFT, CH_CANCEL);
            break;
          default:
            wimp_processkey(e->data.key.chcode);
        }
        break;
      case wimp_ESEND:
      case wimp_ESENDWANTACK:
        if(e->data.msg.hdr.action==wimp_MHELPREQUEST)
        {
            char tag[2]={0};
            int  i=e->data.msg.data.helprequest.m.i;

            if(i>=0) tag[0]=i+1;
            help_genmessage("HdCH",tag);
        }
        else if (e->data.msg.hdr.action==0x400c9)
            font_item = 0;

        break;
    }
}

static void choices_button_handler(wimp_bbits bbits, wimp_i icon)
{
    int menusize, datasize;
    wimp_icon is;
    wimp_wstate ws;
    extern void event_cancel_menu(void);

    if (bbits == wimp_BMID && !(icon == CH_FONT_BODY_POPUP ||
        icon == CH_FONT_FIXED_POPUP || icon == CH_FONT_HEADINGS_POPUP))
        return;

    switch (icon)
    {
      case CH_CANCEL:
        reset_choices_window();
        break;
      case CH_SAVE:
      case CH_SET:
        read_choices_window();
        if (icon == CH_SAVE)
            wimpt_complain(saveprefs());
        break;
      case CH_DEFAULT:
        set_default_choices();
        break;
      case CH_NETWORK_CONFIG:
        wimpt_complain(iconbar_netprefs());
        break;
      case CH_FONT_FIXED_POPUP:
      case CH_FONT_BODY_POPUP:
      case CH_FONT_HEADINGS_POPUP:
        _swix(Font_ListFonts, _INR(1,2)|_IN(4)|_IN(6)|_OUT(3)|_OUT(5),
                               0, 0 | (1<<19) | (1<<21),
                               0, 0, &menusize, &datasize);
        free(font_menubuf);
        free(font_databuf);
        font_menubuf=malloc(menusize);
        font_databuf=malloc(datasize);
        font_item=icon - 1;
        if (font_menubuf == 0 || font_databuf == 0)
            return;
        wimp_get_icon_info(ChoicesW, font_item, &is);
        _swix(Font_ListFonts, _INR(1,6),
                              font_menubuf, 0 | (1<<19) | (1<<21),
                              menusize, font_databuf, datasize,
                              is.data.indirecttext.buffer);
        wimp_get_icon_info(ChoicesW, icon, &is);
        wimp_get_wind_state(ChoicesW, &ws);
        coords_box_toscreen(&is.box, (coords_cvtstr *) &ws.o.box);
        event_cancel_menu();
        wimp_create_menu(font_menubuf, is.box.x0+44+2, is.box.y1);
        break;
    }

    if ((icon == CH_SET || icon == CH_CANCEL || icon == CH_SAVE) &&
        bbits == wimp_BLEFT)
        wimp_close_wind(ChoicesW);
}

static BOOL choices_menu_handler(wimp_eventstr *e, void *handle)
{
    char buffer[256], *p, *p2;
    wimp_mousestr ms;
    wimp_icon is;
    int present;

    if (e->e != wimp_EMENU || font_item == 0)
        return FALSE;

    wimp_get_icon_info(ChoicesW, font_item, &is);

    _swix(Font_DecodeMenu, _INR(0,4), 0, font_menubuf, e->data.menu,
                                      buffer, sizeof buffer);

    _swix(Font_FindField, _INR(1,2)|_OUTR(1,2), buffer, 'F', &p2, &present);

    if (present)
    {
        for (p = p2; *p > ' ' && *p != '\\'; p++)
            continue;
        *p = '\0';
        strncpy(is.data.indirecttext.buffer, p2, is.data.indirecttext.bufflen);
        wimp_set_icon_state(ChoicesW, font_item, (wimp_iconflags) 0,
                                                 (wimp_iconflags) 0);
    }
    wimp_get_point_info(&ms);
    if (ms.bbits == wimp_BRIGHT) {
        _swix(Font_ListFonts, _INR(1,6),
                              font_menubuf, 0 | (1<<19) | (1<<21),
                              1024*1024, font_databuf, 1024*1024, /* Yuck!!! */
                              p2);
        wimp_create_menu(font_menubuf, 0, 0);
    }

    return TRUE;
}



/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define NI_POSTIN 3
#define NI_POSTOUT 5
#define NI_RADIO_BASE 8
#define NI_RADIO_NONE 8
#define NI_RADIO_LOCAL 9
#define NI_RADIO_ACCESS 10
#define NI_RADIO_AUN 11
#define NI_RADIO_IP 12
#define NI_PROXY_TEXT 13

static win_event_handler old_netprefs_handler;
static void *old_netprefs_handle;

static void netprefs_sortout_caret(dbox d, wimp_i i)
{
    wimp_w w=dbox_syshandle(d);
    wimp_caretstr c;

    wimp_get_caret_pos(&c);

    switch (i)
    {
      case NI_RADIO_NONE:
      case NI_RADIO_LOCAL:
        if (c.w == w)
        {
            c.i=-1;
            c.height=1<<25;
            wimp_set_caret_pos(&c);
        }
        dbox_fadefield(d, NI_PROXY_TEXT);
        break;
      case NI_RADIO_AUN:
      case NI_RADIO_ACCESS:
      case NI_RADIO_IP:
        if (c.w == w)
        {
            c.i = NI_PROXY_TEXT;
            c.height=-1;
            c.index=256;
            wimp_set_caret_pos(&c);
        }
        dbox_unfadefield(d, NI_PROXY_TEXT);
        break;
    }
}

static void netprefs_drag_handler(wimp_eventstr *event, void *handle)
{
    dbox d=(dbox) handle;
    int i;
    char *name;

    if (event->e != wimp_ESEND && event->e != wimp_ESENDWANTACK)
    {
        if (old_netprefs_handler)
            old_netprefs_handler(event, old_netprefs_handle);
        return;
    }

    if (event->data.msg.hdr.action == wimp_MDATALOAD &&
        strncmp(event->data.msg.data.dataload.name, "Resources:$.Discs.", 18) == 0)
    {
        dbox_setnumeric(d, NI_RADIO_ACCESS, 1);
        netprefs_sortout_caret(d, NI_RADIO_ACCESS);
        dbox_setfield(d, NI_PROXY_TEXT, event->data.msg.data.dataload.name+18);
    }

    if (event->data.msg.hdr.action != wimp_MDATALOAD ||
        event->data.msg.data.dataload.type < 0x1000)
    {
        if (old_netprefs_handler)
            old_netprefs_handler(event, old_netprefs_handle);
        return;
    }

    i=event->data.msg.data.dataload.i;
    name=event->data.msg.data.dataload.name;

    if (i == NI_POSTIN || i == NI_POSTOUT)
        dbox_setfield(d, i, name);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static os_error *iconbar_netprefs(void)
{
  dbox d;
  int  f;
  char buffer[256], *stype, *sval, *p;
  int  type, i;
  _kernel_oserror *e;

  d=dbox_new("poffice");
  if(!d) return(errorgen(2));
  dbox_raw_eventhandler(d,help_dboxrawevents,"HdPO");
  if (!win_read_eventhandler(dbox_syshandle(d), &old_netprefs_handler, &old_netprefs_handle))
  {
    old_netprefs_handler=0;
    old_netprefs_handle=0;
  }
  win_register_event_handler(dbox_syshandle(d),netprefs_drag_handler,d);

  e=_swix(OS_Module, _INR(0,1), 18, "Freeway");

  if (e)
    dbox_fadefield(d, NI_RADIO_ACCESS);

  #ifdef SINGLE_USER
  dbox_fadefield(d, NI_POSTIN);
  dbox_fadefield(d, NI_POSTOUT);
  #endif

  e=_swix(OS_Module, _INR(0,1), 18, "Net");
  if (e)
    e=_swix(OS_Module, _INR(0,1), 18, "NetG");

  if (e)
    dbox_fadefield(d, NI_RADIO_AUN);

  dbox_setfield(d, NI_POSTIN, params.post_in);
  dbox_setfield(d, NI_POSTOUT, params.post_out);

  strcpy(buffer, params.proxy);

  stype=strtok(buffer, ";");
  sval=strtok(NULL, ";");
  if (sval==NULL)
    sval="";

  p=strstr(proxytype, stype);
  if (p)
      type=(p-proxytype)/8;
  else
      type=0;

  dbox_setnumeric(d, NI_RADIO_BASE+type, 1);
  netprefs_sortout_caret(d, NI_RADIO_BASE+type);
  dbox_setfield(d, NI_PROXY_TEXT, sval);

  dbox_showstatic(d);
  do
  {
    f=dbox_fillin(d);
    switch (f)
    {
      case 0:
        dbox_getfield(d, NI_POSTIN, params.post_in, sizeof params.post_in);
        dbox_getfield(d, NI_POSTOUT, params.post_out, sizeof params.post_out);
        for (i=NI_RADIO_NONE; i <= NI_RADIO_IP; i++)
        {
            wimp_icon icon;
            wimp_get_icon_info(dbox_syshandle(d), i, &icon);
            if (icon.flags & wimp_ISELECTED)
            {
                type=i-NI_RADIO_BASE;
                break;
            }
        }
        strncpy(params.proxy, proxytype+type*8, 8);
        p=strchr(params.proxy, ' ');
        p[0]=';';
        if (type >= 2)
            dbox_getfield(d, NI_PROXY_TEXT, p+1, (params.proxy+sizeof params.proxy)-(p+1));
        else
        {
            dbox_setfield(d, NI_PROXY_TEXT, "");
            p[1]='\0';
        }
        sval=p+1;
        wimpt_complain(iconbar_setproxy());
        if (!logged_in) {
            read_choices_window();
            wimpt_complain(saveprefs());
            wimp_close_wind(ChoicesW);
        }
        break;
      case 1:
        dbox_setfield(d, NI_POSTIN, params.post_in);
        dbox_setfield(d, NI_POSTOUT, params.post_out);
        dbox_setnumeric(d, NI_RADIO_BASE+type, 1);
        dbox_setfield(d, NI_PROXY_TEXT, sval);
        break;
      case NI_RADIO_NONE:
      case NI_RADIO_LOCAL:
      case NI_RADIO_AUN:
      case NI_RADIO_ACCESS:
      case NI_RADIO_IP:
        dbox_setnumeric(d, f, 1);
        netprefs_sortout_caret(d, f);
        break;
    }
  } while(f!=dbox_CLOSE && ((f!=0 && f!=1) || dbox_persist()));
  dbox_dispose(&d);

  /* Get us out of query state, possibly? */
  if (!logged_in)
    re_login=TRUE;

  return(NULL);
}


/*----------------------------------------------------------------------*/
void iconbar_menuproc(void *handle, char *hit)
{
  handle=handle;
  switch(hit[0])
  {
    case MO_BROWSE_INFO: wimpt_complain(main_proginfo()); break;
    case MO_BROWSE_CHOICES: choices_open(); break;
    case MO_BROWSE_QUIT:
    {
      iconbar_shutdown();
      exit(0);
    } break;
  }
}

/*----------------------------------------------------------------------*/
menu iconbar_menumaker(void *pHandle)
{
pHandle=pHandle;
/* Grey out everything on prefs menu except network if we're not logged in */
/*menu_setflags(m_preferences,MO_PREFERENCES_TOOLBAR,params.toolbar,!logged_in);
menu_setflags(m_preferences,MO_PREFERENCES_STATUSBAR,params.statusbar,!logged_in);
menu_setflags(m_preferences,MO_PREFERENCES_URLBAR,params.urlbar,!logged_in);
menu_setflags(m_preferences,MO_PREFERENCES_DELAYIMAGELOADING,params.delayimages,!logged_in);
menu_setflags(m_preferences,MO_PREFERENCES_FONTS,FALSE,!logged_in);
menu_setflags(m_preferences,MO_PREFERENCES_SAVE,FALSE,!logged_in);
menu_setflags(m_browser,MO_BROWSER_PREFERENCES,FALSE,!have_write_access());*/
/*menu_setflags(m_browser,MO_BROWSER_LOGON,FALSE,TRUE);*/
return(m_browse);
}

/*----------------------------------------------------------------------*/
BOOL iconbar_unknown_event(wimp_eventstr *e, void *handle)
{
handle=handle;
switch (e->e)
  {
  case wimp_ENULL        : idle_call_users(); return(TRUE); break;
  case wimp_EMENU        : form_select_menu_event(e); break;
  case wimp_EACK:
  {
    /* PrintSave bounced, so print now (no printer manager loaded, */
    /* but the modules are there).                                 */

    if (e->data.msg.hdr.action == Browser_Message_PrintSave)
    {
      print_print(NULL);
      return (TRUE);
    }
  }
  break;
  case wimp_ESEND        : /* No break */
  case wimp_ESENDWANTACK : return(iconbar__esendwantack(e)); break;
  }
return(FALSE);
}
