#define NOIDLETRACE

/*

  Merlyn Kline, 1995

:NOTES

This module manages the browser windows. It uses a linked list of malloc'd
blocks each containing a browser struct. This in turn contains a flex
anchor pointing to a flex block containing the data for this window.

The flex block contains the following items:

  - A data chunk (browser.hsize bytes) with a set of consecutive zero-
    terminated strings representing the history list (oldest first).
  - browser.fsize bytes containing the URL of the page being fetched (if any)
  - browser.usize bytes containing the URL of the currently displayed
    page.
  - browser.tsize bytes containing a list of tokens representing the current
    page. Each token is stored in browser_token structure.
  - browser.dsize bytes containing the token data. The data for the tokens are
    stored in the same order as the tokens with the size of each chunk rounded
    up for word alignment.
  - browser.lsize bytes containing a list of line structures for the display
    as currently formatted. Each of these is a browser_line structure.

The sizes stored are the actual allocation. This may not be eintirely used
as space is allocated in BLOCKSIZE or word chunks. Among other things, this ensures
that each block starts on a word boundary.

The global history is also maintained by this module. It is stored in a flexblock
as a series of word-aligned structures, each consisting of an integer and a string.
The integer is the monotonic time of last use, the string is a zero-terminated URL.

:END

:MESSAGES
GETFIL:Please enter pathname of file to display:
GETLOC:Please enter URL to display:
HdGETLOC:This dialogue allows you to specify a page to be displayed.
HdGETLOC0:Click SELECT to display the chosen page.
HdGETLOC1:Click SELECT to cancel the dialogue without loading a page.
HdGETLOC3:Enter the URL of the page in this field.
BLANK:Blank page
HdFIND:This dialogue allows you to search the displayed page for a particular piece of text.
HdFIND0:Click SELECT to start searching from the start of the page.
HdFIND1:Click SELECT to cancel the search.
HdFIND2:Enter the text you want to search for in this field.
HdFIND5:Click SELECT to start searching from the top of the window.
HdFIND6:Choose this option to force the search to check whether letters are the same case.
HdPRINT:This dialogue lets you print the page currently being displayed.
HdPRINT0:Click SELECT to print the displayed page.
HdPRINT1:Click SELECT to cancel the print.
HdPRINT2:This field shows you what type of printer is currently selected in your printer driver.
HdPRINT4:Enter the number of copies you want printed in this field.
NODRIVE:No driver loaded
HwBROW1:This window displays the current page.|MClick SELECT to follow this link.|MClick ADJUST to open a new window with this link.
HwBROW2:This window displays the current page.
HmMAIN0:Click SELECT to save the current page as an HTML file.|MMove the pointer to the right to export different formats or print.
HmMAIN00:Click SELECT or move the pointer to the right to save the current page as an HTML file.
HmMAIN01:Move the pointer to the right to export the current page.|MClick SELECT to export the current page as a Draw file.
HmMAIN010:Click SELECT or move the pointer to the right to export the current page as a Draw file.
HmMAIN011:Click SELECT or move the pointer to the right to export the current page as plain ASCII text.
HmMAIN012:Click SELECT or move the pointer to the right to save the data pointed to by the current link.
HmMAIN013:Click SELECT or move the pointer to the right to export the current picture as a sprite.
HmMAIN02:Click SELECT or move the pointer to the right to print the current page.
HmMAIN1:Click SELECT to go to a new page.|MMove the pointer to the right to re-visit or move to different pages.
HmMAIN10:Click SELECT or move the pointer to the right to go to a new page.
HmMAIN11:Click SELECT to display the home page.
HmMAIN12:Click SELECT to return to the previously displayed page from the history list.
HmMAIN13:Click SELECT to move forward through the history list.
HmMAIN14:Click SELECT to re-load this page.
HmMAIN15:Click SELECT to interrupt the current fetch.
HmMAIN16:Click SELECT to display the images associated with this page.
HmMAIN2:Move the pointer to the right to manipulate the hot list.|MClick SELECT to choose a page from the hot list.
HmMAIN20:Click SELECT or move the pointer to the right to choose a page from the hot list.
HmMAIN21:Click SELECT to add the displayed page to your hot list.
HmMAIN22:Click SELECT or move the pointer to the right to remove a page from the hot list.
HmMAIN23:Click SELECT or move the pointer to the right to save the hor list as an HTML file.
HmMAIN3:Click SELECT or move the pointer to the right to choose a page from the resources.
HmMAIN4:Move the pointer to the right to search the text, turn the toolbar etc on or off and change image display.|MClick SELECT to search the current page.
HmMAIN40:Click SELECT or move the pointer to the right to search the current page.
HmMAIN41:Click SELECT to turn the URL bar at the top of the window on or off.
HmMAIN42:Click SELECT to turn the toolbar at the top of the window on or off.
HmMAIN43:Click SELECT to turn the status bar at the bottom of the window on or off.
HmMAIN44:Click SELECT to turn on or off delayed image loading.|MWhen image loading is delayed images are not displayed until specifically requested.
HmMAIN45:Click SELECT to enable or disable the display of background images (when available) under the main text.
:END

:HISTORY
:END

*/

#include "stdlib.h"
/*----------------------------------------------------------------------*/
#include "stdio.h"
#include "stddef.h"
#include "string.h"
#include "ctype.h"
#include "time.h"

/*----------------------------------------------------------------------*/
#include "wimp.h"
#include "flex.h"
/*----------------------------------------------------------------------*/
#include "template.h"
#include "event.h"
#include "win.h"
#include "bbc.h"
#include "wimpt.h"
#include "dboxfix.h"
#include "help.h"
#include "msgs.h"
#include "os.h"
#include "swis.h"
#include "print.h"
#include "coords.h"
#include "font.h"
#include "sprite.h"
#include "xferrecv.h"
#include "akbd.h"

#if 0
/* this #include html.h is just here so that Genh2 will export it */
/*----------------------------------------------------------------------*/
#include "html.h"
#endif

#include "Button.h"
/*----------------------------------------------------------------------*/
#include "Panes.h"
#include "MenuDefs.h"
#include "Status.h"
#include "Iconbar.h"
#include "Main.h"
#include "Browser.h"
#include "Hotlist.h"
#include "Bone.h"
#include "Reformat.h"
#include "Redraw1.h"
#include "Defs.h"
#include "FontManage.h"
#include "Redraw.h"
#include "Fetch.h"
#include "Save.h"
#include "URLv.h"
#include "mflex.h"
#include "Images.h"
#include "Forms.h"
#include "Printing.h"
#include "Utils.h"
#include "trace.h"

/*----------------------------------------------------------------------*/
#include "struct.h"

#if 0
/* typdefs are #if'd out as they are in headers */

/*----------------------------------------------------------------------*/
typedef enum bs_fetch
{ /* statuses for fetch */
  BS_IDLE=0,       /* nothing happening, no fetch in progress */
  BS_START,        /* fetch to be started on next null event */
  BS_STARTED,      /* the fetch has started but nothing has arrived yet */
  BS_IDENTIFY,     /* we are attempting to identify the nature of the URL */
  BS_FETCHING,     /* fetching in progress */
  BS_DATAFETCH     /* being fetched by saveas as a non-renderable file */
} bs_fetch;

/*----------------------------------------------------------------------*/
typedef struct browser
{
  struct browser *next; /* pointer to next open browser window */
  void           *hdata; /* flex anchor for data in this window (see above) */
  void           *idata; /* flex anchor for image data */
  void           *fdata; /* flex anchor for form data */
  void           *source; /* flex anchor for this window's source HTML */
  char           title[256]; /* this is here so the template can be pointed at it */
  char           status_str[200]; /* the status line for this browser */
  wimp_w         w;
  pane_data      buttonbar;
  pane_data      urlbar;
  pane_data      status;
  pane_data      terminator; /* dummy pane needed to terminate list */
  template       *t; /* pointer to the template for the browser window */
  template       *t_u; /* pointer to the template for the browser window URL bar */
  template       *t_b; /* pointer to the template for the browser window button bar */
  template       *t_s; /* pointer to the template for the browser window status bar */
  int            hsize; /* bytes occupied by history list */
  int            fsize; /* bytes used for URL being fetched */
  int            usize; /* bytes used for URL being displayed */
  int            tsize; /* bytes used for list of tokens representing page */
  int            dsize; /* bytes used for stored token data */
  int            lsize; /* bytes used for list of line structures representing formatted page */
  int            hnum; /* number of entries in history list */
  int            hpos; /* current positon in history list (0=not in history, 1-n = on that entry) */
  int            animate; /* currently displayed animation sprite */
  int            lastframetime; /* time since last animation frame */
  int            ntokens; /* number of tokens in the token list */
  int            datasize; /* amount of data actually stored in data block */
  int            nlines; /* number of line structures in the line list */
  int            lbytes; /* number of bytes occupied by line list (out of the lsize bytes allocated) */
  int            idle_count; /* count of idle events between window opens */
  int            display_width; /* width the page is currently formatted to (OS units) */
  int            max_width; /* the maximum width of the page discovered by the formatter */
  bs_fetch       status_fetch; /* current fetching status */
  int            h_display; /* the html-lib handle of the displayed document */
  int            h_fetch; /* the html-lib handle of the document being fetched */
  int            ptr_link; /* the identity of the link under the pointer */
  int            reformat_extent; /* the y extent of the window set by the reformatter */
  int            reformat_width;  /* the x extent of the window set by the reformatter */
  int            display_request; /* token to display at top of window ASAP */
  int            display_request_offset; /* offset into token to display at top of window */
  int            suspend_format; /* flag to suspend reformatting in case an error occurs */
  int            delayimages; /* delay image loading in this window */
  int            plainback; /* don't display background images in this window */
  int            last_reformat_token; /* number of last token for which reformat has definitely completed */
  HStream        *stream; /* pointer to the stream of tokens */
  int            nimages; /* counter for images in this page */
  int            nforms; /* counter for forms on this page */
  int            lastimage; /* last image number processed in a null */
  int            backgroundcol; /* background colour word */
  int            linkcol; /* link colour word */
  int            textcol; /* text colour word */
  int            usedcol; /* followed link colour word */
  int            backimage; /* the image number of the background image (1..nimages, 0=none) */
  int            aacol; /* colour to anti-alias text to, -1=don't anti-alias */
  int            highlight; /* highlighted token (eg pressed button), 0=none */
  int            bytes_fetched; /* bytes fetched on this page, including images */
  BOOL           reloading; /* this fetch is a reload (ie no proxy) */
  void           *extradata; /* extension data for form fetches */
  FILE           *savefile; /* file handle for saving data */
  int            savetype; /* filetype for saved data */
  int            savelink; /* flag - save the next fetch as data even if its parseable */
  int            stoplooking; /* flag - don't watch for a named anchor anymore */
} browser;

/*----------------------------------------------------------------------*/
typedef struct browser_token
{
  int  type;        /* Token type */
  int  flags;       /* Token flags */
  int  length;      /* Length of data or input field */
} browser_token;

#endif

/*----------------------------------------------------------------------*/
#include "Fetch.h"

#define DEFAULT_WIDTH 1280

#if 0
/* exported #defines are #if'd out as they are in the header */
/*----------------------------------------------------------------------*/
#define BLOCKSIZE 256 /* size of blocks allocated in flex */

/*----------------------------------------------------------------------*/
#define FILEMETHOD "file://"

/*----------------------------------------------------------------------*/
#define DEFAULT_HEIGHT 1320

/*----------------------------------------------------------------------*/
#define BUTTONBAR_HEIGHT 80

/*----------------------------------------------------------------------*/
#define URLBAR_HEIGHT 72

/*----------------------------------------------------------------------*/
#define STATUS_HEIGHT 96

/*----------------------------------------------------------------------*/
#define FILETYPE_TEXT (0xfff)
/*----------------------------------------------------------------------*/
#define FILETYPE_HTML (0xfaf)
/*----------------------------------------------------------------------*/
#define FILETYPE_SPRITE (0xff9)
/*----------------------------------------------------------------------*/
#define FILETYPE_DRAW (0xaff)
/*----------------------------------------------------------------------*/
#define FILETYPE_DATA (0xffd)
/*----------------------------------------------------------------------*/
#define FILETYPE_PRINTOUT (0xff4)

/*----------------------------------------------------------------------*/
#define CK_HIST 0
/*----------------------------------------------------------------------*/
#define CK_FURL 1
/*----------------------------------------------------------------------*/
#define CK_DURL 2
/*----------------------------------------------------------------------*/
#define CK_TKNS 3
/*----------------------------------------------------------------------*/
#define CK_DATA 4
/*----------------------------------------------------------------------*/
#define CK_LINE 5

#endif

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static browser *browser_list=NULL; /* pointer to the first browser in the list */
void           *global_history=NULL; /* flex_anchor for the global history */
static int     browser_menu_token; /* the token number menu was clicked on */
static void    *authorise=NULL; /* flex anchor for list of authorisation passwords */

/*----------------------------------------------------------------------*/
os_error *browser_destroy_source(browser *b)
{
  if(b->source) mflex_free((flex_ptr)&b->source);
  b->source=NULL;
  return(NULL);
}

/*----------------------------------------------------------------------*/
os_error *browser_set_chunk_size_f(browser *b,int chunk,int size)
{
  /* set the size of the data chunk, where chunk =
      0: History list
      1: Fetching URL
      2: Displayed URL
      3: Token list
      4: Token data
      5: Line list
     all other data are moved accordingly
  */
  int *sizep;
  int offset,oldchunksize,success;

  switch(chunk)
  {
    case CK_HIST: sizep=&b->hsize; offset=0; break;
    case CK_FURL: sizep=&b->fsize; offset=b->hsize; break;
    case CK_DURL: sizep=&b->usize; offset=b->hsize+b->fsize; break;
    case CK_TKNS: sizep=&b->tsize; offset=b->hsize+b->fsize+b->usize; break;
    case CK_DATA: sizep=&b->dsize; offset=b->hsize+b->fsize+b->usize+b->tsize; break;
    default     : sizep=&b->lsize; offset=b->hsize+b->fsize+b->usize+b->tsize+b->dsize; break;
  }
  oldchunksize=*sizep;
  if(oldchunksize!=size)
  {
    if(b->hdata)
    {
      int olddatasize;

      olddatasize=mflex_size(&b->hdata);
      if(oldchunksize>size)
        memmove(((char*)b->hdata)+offset+size,((char*)b->hdata)+offset+oldchunksize,
                olddatasize-offset-oldchunksize);
      success=mflex_extend(&b->hdata,olddatasize+size-oldchunksize);
      if(success && oldchunksize<size)
        memmove(((char*)b->hdata)+offset+size,((char*)b->hdata)+offset+oldchunksize,
                olddatasize-offset-oldchunksize);
    }
    else
      success=mflex_alloc(&b->hdata,size);
    if(success)
    {
      *sizep=size;
      return(NULL);
    }
    return(errorgen(2));
  }
  return(NULL);
}

/*----------------------------------------------------------------------*/
int browser_bar_height(browser *b)
{
  int c,y,dy;

  dy=Wimpt_dy;
  c=y=0;
  if(b->buttonbar.flags&PANE_ISOPEN) {y+=BUTTONBAR_HEIGHT+dy; c++;}
  if(b->urlbar.flags&PANE_ISOPEN) {y+=URLBAR_HEIGHT+dy; c++;}
  if(c>1) y+=dy;
  return(y);
}


/*----------------------------------------------------------------------*/
int browser_token_to_line(browser *b,int token)
{
  int                 c,l;
  reformat_line       *lp;
  reformat_line_chunk *cp;

  l=1;
  lp=reformat_line_address(b,1);
  while(l<=b->nlines)
  {
    cp=reformat_line_chunk_address(lp,0);
    for(c=0;c<lp->n;c++,cp++)
      if(cp->t>=token) return(l);
    l++;
    lp=reformat_next_line_address(lp);
  }
  return(0);
}

/*----------------------------------------------------------------------*/
BOOL browser_show_token(browser *b,int token,int offset)
{ /* make the specified token appear at the top of the window, return success flag */
  reformat_line       *lp;
  reformat_line_chunk *cp;
  int                 c,l,y,fy;
  wimp_wstate         state;
  BOOL                found;

  if(token<1 || token>b->ntokens) return(FALSE);
  l=browser_top_line(b);
  if(l>0)
  {
    lp=reformat_line_address(b,l);
    cp=reformat_line_chunk_address(lp,0);
    for(c=0;c<lp->n;c++,cp++)
      if(cp->t==token && cp->o<=offset && cp->l+cp->o>offset) return(TRUE);
  }
  if(wimp_get_wind_state(b->w,&state)) return(FALSE);
  l=1;
  lp=reformat_line_address(b,1);
  fy=0;
  y=-1;
  found=FALSE;
  while(l<=b->nlines && !found)
    {
      y=lp->y+lp->h-1;
      cp=reformat_line_chunk_address(lp,0);
      for(c=0;c<lp->n && !found;c++,cp++)
      {
        if(cp->t>=token && cp->o<=offset && (cp->l+cp->o>offset || cp->l==0))
        {
          if(fy==0) fy=y;
          found=TRUE;
        }
      }
      l++;
      lp=reformat_next_line_address(lp);
    }
  if(!found) return(FALSE);
  state.o.y=fy+browser_bar_height(b)+1+4;
  if(wimp_open_wind(&state.o)) return(FALSE);
  return(TRUE);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static os_error *browser_show_named_anchor(browser *b,char *anchor_name)
{
  if(!browser_show_token(b,fetch_find_anchor_token(b,anchor_name),0)) bbc_vdu(7);
  return(NULL);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static BOOL browser_show_named_anchor_quietly(browser *b, char * anchor_name)
{
  return browser_show_token(b,fetch_find_anchor_token(b,anchor_name),0);
}

/*----------------------------------------------------------------------*/
int browser_line_at_y(browser *b,int y)
{
  int           cy,l;
  reformat_line *lp;

  l=1;
  cy=-1;
  lp=reformat_line_address(b,1);
  while(l<=b->nlines && cy>y) {cy=lp->y; l++; lp=reformat_next_line_address(lp);}
  return(l-1);
}

/*----------------------------------------------------------------------*/
int browser_top_line(browser *b)
{ /* get the number of the topmost wholly visible line */
  wimp_wstate   state;
  int           y,l;
  reformat_line *lp;

  if(wimp_get_wind_state(b->w,&state)) return(0);
  y=coords_y_toworkarea(state.o.box.y1-browser_bar_height(b)-4,(coords_cvtstr*)&state.o.box);
  l=1;
  lp=reformat_line_address(b,1);
  while(l<b->nlines && lp->y+lp->h>y) {l++; lp=reformat_next_line_address(lp);}
  return(l);
}

/*-------------------------------------------------------------------*/
void browser_redraw_title(browser *b)
{
  char           buf[sizeof(wimp_winfo)+sizeof(wimp_icon)];
  wimp_winfo     *i;
  wimp_redrawstr r;

  i=(wimp_winfo*)buf;
  i->w=b->w;
  wimp_get_wind_info(i);
  r.w=-1;
  r.box.x0=i->info.box.x0;
  r.box.x1=i->info.box.x1;
  r.box.y0=i->info.box.y1+1;
  r.box.y1=r.box.y0+36-1;
  wimp_force_redraw(&r);
}

/*-------------------------------------------------------------------*/
/*ml: case insensitive string compare with maxlen, returns -1 0 1 */
int ml_strncmpi(char *s1,char *s2,int maxlen)
{
  int a,b;

  if(maxlen)
  {
    a=toupper(*s1);
    b=toupper(*s2);
    while (a==b && a && --maxlen)
    {
      a=toupper(*++s1);
      b=toupper(*++s2);
    }
    if(a==b) return(0);
    return(a<b?-1:1);
  }
  return(0);
}

/*----------------------------------------------------------------------*/
os_error *browser_give_focus_general(browser *b)
{
  /* give the specified browser the input focus in no particular place */
  wimp_caretstr c;

  if(form_give_focus(b)) return(NULL);
  if(b->urlbar.flags&PANE_ISOPEN)
  {
    wimp_icon ic;
    char      *p;

    wimp_get_icon_info(b->urlbar.w,2,&ic);
    p=strchr(ic.data.indirecttext.buffer,'\r');
    if(p) *p=0;
    c.w=b->urlbar.w;
    c.i=2;
    c.index=strlen(ic.data.indirecttext.buffer);
    c.x=c.y=0;
    c.height=-1;
  }
  else
  {
    c.w=b->w;
    c.i=-1;
    c.x=-1;
    c.y=1;
    c.height=0;
  }
  return(wimp_set_caret_pos(&c));
}

/*----------------------------------------------------------------------*/
os_error *browser_destroy_window_f(browser *b)
{ /* destroy a browser window and all its associated bits and pieces
     if they exist. This works for partly created windows. */
  if(b)
  {
    browser_stop_f(b,TRUE);
    idle_deregister_handle(b);
    if(b->h_display==b->h_fetch) b->h_display=0;
    if(b->h_fetch) {browser_destroy_source(b); html_close(b->h_fetch); b->h_fetch=0;}
    if(b->h_display) {browser_destroy_source(b); html_close(b->h_display); b->h_display=0;}
    if(b->savefile) {fclose(b->savefile); b->savefile=NULL;}
    image_discard(b);
    form_discard(b);
    if(b==browser_list)
      browser_list=b->next; /* delete the first entry in the list */
    else
    { /* find the entry in the list and point the preceding one past it */
      browser **l;

      l=&browser_list;
      while(*l && (*l)->next!=b) l=&((*l)->next);
      if(*l) (*l)->next=b->next;
    }
    if(b->buttonbar.w)
    {
      event_attachmenumaker(b->buttonbar.w,NULL,NULL,(void*)b);
      win_register_event_handler(b->buttonbar.w,NULL,(void*)b);
      wimp_close_wind(b->buttonbar.w);
      wimp_delete_wind(b->buttonbar.w);
      b->buttonbar.w=NULL;
    }
    if(b->urlbar.w)
    {
      event_attachmenumaker(b->urlbar.w,NULL,NULL,(void*)b);
      win_register_event_handler(b->urlbar.w,NULL,(void*)b);
      wimp_close_wind(b->urlbar.w);
      wimp_delete_wind(b->urlbar.w);
      b->urlbar.w=NULL;
    }
    if(b->status.w)
    {
      event_attachmenumaker(b->status.w,NULL,NULL,(void*)b);
      win_register_event_handler(b->status.w,NULL,(void*)b);
      wimp_close_wind(b->status.w);
      wimp_delete_wind(b->status.w);
      b->status.w=NULL;
    }
    if(b->w)
    {
      event_attachmenumaker(b->w,NULL,NULL,(void*)b);
      win_register_event_handler(b->w,NULL,(void*)b);
      wimp_close_wind(b->w);
      wimp_delete_wind(b->w);
      b->w=NULL;
    }
    if(b->t)
    {
      if(b->t->workspacesize) free(b->t->workspace);
      free(b->t);
      b->t=NULL;
    }
    if(b->t_u)
    {
      if(b->t_u->workspacesize) free(b->t_u->workspace);
      free(b->t_u);
      b->t_u=NULL;
    }
    if(b->t_b)
    {
      if(b->t_b->workspacesize) free(b->t_b->workspace);
      free(b->t_b);
      b->t_b=NULL;
    }
    if(b->t_s)
    {
      if(b->t_s->workspacesize) free(b->t_s->workspace);
      free(b->t_s);
      b->t_s=NULL;
    }
    if(b->hdata) mflex_free(&b->hdata);
    if(b->extradata) mflex_free(&b->extradata);
    free(b);
  }
/*
  if(!browser_list) iconbar_logout();
*/
  return(NULL);
}

/*----------------------------------------------------------------------*/
os_error *browser_destroy_all_f(void)
{ /* destroy all browser windows */
  while(browser_list) browser_destroy_window_f(browser_list);
  return(NULL);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static os_error *b_e_f(browser *b,os_error *e)
{
  if(e)
  {
    e=errorgen((int)e);
    browser_destroy_window_f(b);
  }
  return(e);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static os_error *browser_redraw(browser *b)
{
  wimp_redrawstr r;
  int            more;

  r.w=b->w;
  wimp_redraw_wind(&r,&more);
  if(more) return(redraw_draw(b,&r,FALSE,FALSE));
  return(NULL);
}

/*----------------------------------------------------------------------*/
os_error *browser_update(browser *b,wimp_redrawstr *r,BOOL noback)
{
  int            more;

  r->w=b->w;
  wimp_update_wind(r,&more);
  if(more) return(redraw_draw(b,r,TRUE,noback));
  return(NULL);
}

/*----------------------------------------------------------------------*/
os_error *browser_update_token(browser *b,int token,BOOL noback)
{
  int                 l,x,y,i;
  reformat_line       *lp;
  reformat_line_chunk *cp;
  HStream             *tp;
  wimp_redrawstr      r;

  l=browser_token_to_line(b,token);
  if(l)
  {
    lp=reformat_line_address(b,l);
    cp=reformat_line_chunk_address(lp,0);
    tp=fetch_token_address(b,cp->t);
    y=lp->y;
    x=redraw_start_x(b,tp,lp,cp);
    convert_pair_to_points(x,y,&x,&y);
    for(i=0;i<lp->n && cp->t!=token;x+=cp->w,i++,cp++);
    convert_pair_to_os(x,y,&x,&y);
    r.box.x0=x;
    r.box.y0=y;
    convert_pair_to_os(cp->w,lp->h,&r.box.x1,&r.box.y1); /* temp use of box.y1 */
    r.box.x1+=r.box.x0+1;
    r.box.y1=r.box.y0+lp->h+1;
    return(browser_update(b,&r,noback));
  }
  return(NULL);
}

/*----------------------------------------------------------------------*/
os_error *browser_update_bottom(browser *b,int topy)
{
  wimp_redrawstr r;

  r.box.x0=-2000000000;
  r.box.x1=-r.box.x0;
  r.box.y0=r.box.x0;
  r.box.y1=topy;
  return(browser_update(b,&r,FALSE));
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static os_error *browser_close_window_f(browser *b)
{
  return(browser_destroy_window_f(b));
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static int browser_display_width(browser *b)
{
  wimp_wstate state;
  int         width;

  wimp_get_wind_state(b->w,&state);
  width=state.o.box.x1-state.o.box.x0; /* visible window width */
  if(width<params.fontsize*2) width=params.fontsize*2; /* minimum we're prepared to format to */
  width&=~31; /* step size so you don't get a reformat on every mouse twitch */
  return(width);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void browser_await_position(void *handle)
{
  browser *b=(browser*)handle;

  b->idle_count++;
  if(b->idle_count>3)
  {
    int         width;

    b->idle_count=0;
    idle_deregister_user(browser_await_position,handle);
    width=browser_display_width(b);
    if(width!=b->display_width)
    {
      if(b->display_request<=0)
      {
        int l;

        l=browser_top_line(b);
        if(l>0)
        {
          reformat_line       *lp;
          reformat_line_chunk *cp=NULL;

          lp=reformat_line_address(b,l);
          cp=reformat_line_chunk_address(lp,0);
          b->display_request=cp->t;
          b->display_request_offset=cp->o;
        }
      }
      b->display_width=width;
      if(wimpt_complain(reformat_format_from(b,0))) browser_destroy_window_f(b);
    }
  }
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static os_error *browser_open_window(browser *b,wimp_openstr *o)
{
  pane_open_window(o,&b->buttonbar);
  if(b->idle_count==0) idle_register_user(browser_await_position,b,FALSE);
  b->idle_count=1;
  return(NULL);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static os_error *browser_reopen_window(browser *b)
{
  wimp_wstate state;
  int         width,height,ow;

  width=bbc_modevar(-1,11)*Wimpt_dx; /* actual screen size */
  height=bbc_modevar(-1,12)*Wimpt_dy;
  wimp_get_wind_state(b->w,&state);
  if(state.o.box.x0<2) state.o.box.x0=2;
  if(state.o.box.x1>width-37) state.o.box.x1=width-37;
  if(state.o.box.y0<40) state.o.box.y0=40;
  if(state.o.box.y1>height-37) state.o.box.y1=height-37;
  pane_open_window(&state.o,&b->buttonbar);
  ow=browser_display_width(b);
  if(ow!=b->display_width)
  {
    b->display_width=ow;
    reformat_format_from(b,0);
  }
  return(NULL);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static int browser_get_pointer_token(browser *b,wimp_mousestr *m,int *ox,int *oy)
{ /* get the link id under the pointer, set *ox,*oy to offset of pointer into token (OS units) */
  wimp_wstate         state;
  int                 x,y,t,line;
  reformat_line       *lp;
  reformat_line_chunk *cp=NULL;

  if(b->w!=m->w || m->i<-1) return(0);
  if(wimp_get_wind_state(b->w,&state)) return(0);
  x=coords_x_toworkarea(m->x,(coords_cvtstr*)&state.o.box);
  y=coords_y_toworkarea(m->y,(coords_cvtstr*)&state.o.box);
  line=browser_line_at_y(b,y);
  if(line<1) return(0);
  convert_pair_to_points(x,y,&x,&t);
  lp=reformat_line_address(b,line);
  if(lp) cp=reformat_line_chunk_address(lp,0);
  if(ox) *ox=0;
  if(oy) *oy=0;
  if(cp)
    {
      int           cx,n;
      HStream       *tp;

      tp=fetch_token_address(b,cp->t);
      cx=redraw_start_x(b,tp,lp,cp);
      convert_pair_to_points(cx,0,&cx,&n);
      if(x<cx) return(0);
      n=lp->n;
      while(n && x>cx+cp->w)
      {
        cx+=cp->w;
        cp++;
        n--;
      }
      if(n)
      {
        wimp_box box;

        tp=fetch_token_address(b,cp->t);
        if(tp->style&IMG)
        {
          reformat_get_image_size(b,cp->t,tp,&box);
          if(ISLINK(tp))
          {
            int b;

            b=tp->maxlen*2;
            box.x1-=b;
            box.y1-=b;
            box.x0+=b;
            box.y0+=b;
          }
        }
        else
        {
          box.x0=0;
          convert_pair_to_os(cp->w,0,&box.x1,&n); /* temporary use of n */
          box.y0=-lp->b;
          box.y1=lp->h-lp->b;
        }
        if(oy)
        {
          *oy=(lp->y+lp->b+box.y1)-y;
          if(*oy<0) *oy=0;
          if(*oy>=(box.y1-box.y0)) *oy=box.y1-box.y0-1;
        }
        if(ox)
        {
          *ox=x-cx;
          convert_pair_to_os(*ox,0,ox,&n); /* temporary use of n */
          if(ISLINK(tp)) *ox-=tp->maxlen*2;
          if(*ox<0) *ox=0;
          if(*ox>=box.x1) *ox=box.x1-1;
        }
        return(cp->t);
      }
    }
  return(0);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static os_error *browser_process_button(browser *b,wimp_eventdata *d)
{
  int           token,ox,oy;
  HStream       *tp;

  token=browser_get_pointer_token(b,&d->but.m,&ox,&oy);
  browser_give_focus_general(b);
  if(token>0)
  {
    tp=fetch_token_address(b,token);
    if((tp->style&FORM) && ((tp->style&INPUT) || (tp->style&TEXTAREA) || (tp->style&SELECT)))
      {ERROUT(form_click_field(b,token,0));}
    else if(ISLINK(tp))
    {
      char url[1024];

      if(!(tp->style&IMG)) browser_flash_token(b,token);
/*
      if(bbc_inkey(-1)) return(fetch_save_link(b,token));
*/
      STRFILL(url,tp->anchor);
      if((tp->type&TYPE_ISMAP) && (tp->style&IMG) && strlen(url)<sizeof(url)-15)
      {
        char *p;

        image_convert_to_pixels(b,token,&ox,&oy);
        p=strchr(url,0);
        sprintf(p,"?%d,%d",ox,oy);
      }
      if(d->but.m.bbits&1) return(browser_new_view_f(url));
      else
      {
        if(b->status_fetch==BS_DATAFETCH) bbc_vdu(7);
        else return(browser_show_url_f(b,url,TRUE));
      }
    }
  }
  return(NULL);
}

/*----------------------------------------------------------------------*/
void browser_pointer_check(void *handle)
{
  browser       *b=(browser*)handle;
  int           token;
  wimp_mousestr m;
  HStream       *tp=NULL;

  if (printing) return;

  wimp_get_point_info(&m);
  token=browser_get_pointer_token(b,&m,NULL,NULL);
  tp=fetch_token_address(b,token);
  if(token>0 && !(ISLINK(tp))) token=0;
  if(token!=b->ptr_link)
  {
    b->ptr_link=token;
    if(!params.fixedptr)
    {
      if(token)
      {
        os_regset r;

        r.r[0]=36;
        r.r[2]=(int)"ptr_link";
        r.r[3]=2;
        r.r[4]=5;
        r.r[5]=0;
        r.r[6]=0;
        r.r[7]=0;
        wimp_spriteop_full(&r);
      }
      else os_cli("Pointer 1");
    }
    status_new_status(b);
  }
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static os_error *browser_pointer_in(browser *b)
{
  b->ptr_link=0;
  idle_register_user(browser_pointer_check,b,FALSE);
  browser_pointer_check(b);
  return(NULL);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static os_error *browser_scroll(browser *b,wimp_eventdata *e)
{
  int ystep;

  ystep=e->scroll.o.box.y1-e->scroll.o.box.y0-browser_bar_height(b)-32;
  if(ystep<32) ystep=32;
  if(b->status.flags&PANE_ISOPEN) ystep-=URLBAR_HEIGHT;
  if(e->scroll.x==-1) e->scroll.o.x-=32;
  if(e->scroll.x== 1) e->scroll.o.x+=32;
  if(e->scroll.x==-2) e->scroll.o.x-=e->scroll.o.box.x1-e->scroll.o.box.x0;
  if(e->scroll.x== 2) e->scroll.o.x+=e->scroll.o.box.x1-e->scroll.o.box.x0;
  if(e->scroll.y==-1) e->scroll.o.y-=32;
  if(e->scroll.y== 1) e->scroll.o.y+=32;
  if(e->scroll.y==-2) e->scroll.o.y-=ystep;
  if(e->scroll.y== 2) e->scroll.o.y+=ystep;
  wimp_open_wind(&e->scroll.o);
  return(NULL);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static os_error *browser_pointer_out(browser *b)
{
  idle_deregister_user(browser_pointer_check,b);
  browser_pointer_check(b);
  return(NULL);
}

/*----------------------------------------------------------------------*/
void browser_window_event(wimp_eventstr *e,void *handle)
{
  browser *b;

  b=(browser*)handle;
  switch(e->e)
  {
    case wimp_EREDRAW:   browser_redraw(b); break;
    case wimp_EOPEN:     browser_open_window(b,&(e->data.o)); break;
    case wimp_ECLOSE:    wimpt_complain(browser_close_window_f(b)); break;
    case wimp_ESCROLL:   wimpt_complain(browser_scroll(b,&e->data)); break;
    case wimp_EBUT:      wimpt_complain(browser_process_button(b,&e->data)); break;
    case wimp_EKEY:      wimpt_complain(browser_process_key(b,e->data.key.chcode)); break;
    case wimp_EPTRENTER: wimpt_complain(browser_pointer_in(b)); break;
    case wimp_EPTRLEAVE: wimpt_complain(browser_pointer_out(b)); break;
    case wimp_ESEND:
    case wimp_ESENDWANTACK:
    {
      switch(e->data.msg.hdr.action)
      {
        case wimp_MDATALOAD:
        {
          char url[1024];
          char *filename;
          int  filetype;

          filetype=xferrecv_checkinsert(&filename);
          xferrecv_insertfileok();
          if(filetype==FILETYPE_HTML || filetype==FILETYPE_TEXT)
          {
            STRFILL(url,filename);
            browser_pathname_to_url(url,sizeof(url));
            wimpt_complain(browser_show_url_f(b,url,TRUE));
          }
        } break;
        case wimp_MHELPREQUEST:
        {
          if(b->ptr_link) help_genmessage("HwBROW1","");
          else help_genmessage("HwBROW2","");
        }
        break;
      }
    }
    break;
  }
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static os_error *browser_scroll_by(browser *b,int amnt)
{ /* amnt=1,2,-1,-2 as per wimp scroll event */
  wimp_eventdata e;
  wimp_wstate    state;

  ERROUT(wimp_get_wind_state(b->w,&state));
  e.scroll.o=state.o;
  e.scroll.x=0;
  e.scroll.y=amnt;
  return(browser_scroll(b,&e));
}

/*----------------------------------------------------------------------*/
os_error *browser_process_key(browser *b,int key)
{
  os_error *e=NULL;

  if(key) e=form_process_key(b,&key);
  if(key && !e)
    switch(key)
    {
      case akbd_Fn+3: e=button_press(B_SAVEHTML,b); break;
      case akbd_Fn+4: e=button_press(B_FIND,b); break;
      case akbd_UpK:           e=browser_scroll_by(b,1); break;
      case akbd_UpK+akbd_Sh:   e=browser_scroll_by(b,2); break;
      case akbd_DownK:         e=browser_scroll_by(b,-1); break;
      case akbd_DownK+akbd_Sh: e=browser_scroll_by(b,-2); break;
      default: e=wimp_processkey(key); break;
    }
  return(e);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static int browser_menu_to_button(browser *b,char *hit)
{
  int     button=B_TERM;

  b=b;
  switch(hit[0])
  {
    case MO_BROWSE_FILE:
      switch(hit[1])
      {
        case MO_NOOPTION:
        case MO_FILE_SAVE:   button=B_SAVEHTML; break;
        case MO_FILE_EXPORT:
          switch(hit[2])
          {
            case MO_NOOPTION:
            case MO_EXPORT_DRAWFILE:  button=B_SAVEDRAW; break;
            case MO_EXPORT_PLAINTEXT: button=B_SAVETEXT; break;
            case MO_EXPORT_LINK:      break;
            case MO_EXPORT_PICTURE:   break;
          }
        break;

        case MO_FILE_PRINT: button=B_PRINT; break;
      }
    break;
    case MO_BROWSE_NAVIGATE:
      switch(hit[1])
      {
        case MO_NOOPTION:
        case MO_NAVIGATE_OPENURL:        button=B_OPENURL;  break;
        case MO_NAVIGATE_HOMEPAGE:       button=B_HOMEPAGE; break;
        case MO_NAVIGATE_BACKONEPAGE:    button=B_BACK;     break;
        case MO_NAVIGATE_FORWARDONEPAGE: button=B_FWD;      break;
        case MO_NAVIGATE_RELOADTHISPAGE: button=B_RELOAD;   break;
        case MO_NAVIGATE_STOP:           button=B_STOP;     break;
        case MO_NAVIGATE_LOADIMAGES:     button=B_IMAGES;   break;
      }
    break;
    case MO_BROWSE_HOTLIST:
      switch(hit[1])
      {
        case MO_NOOPTION:
        case MO_HOTLIST_GOTOPAGE:    button=B_HOTLIST; break;
        case MO_HOTLIST_ADDTHISPAGE: button=B_ADDHOT;  break;
        case MO_HOTLIST_REMOVEPAGE:  button=B_SUBHOT;  break;
        case MO_HOTLIST_SAVE:        button=B_SAVEHOT; break;
      }
    break;
    case MO_BROWSE_RESOURCES: button=B_RESOURCE; break;
    case MO_BROWSE_UTILITIES:
      switch(hit[1])
      {
        case MO_NOOPTION:
        case MO_UTILITIES_FINDTEXT:   button=B_FIND; break;
        case MO_UTILITIES_URLBAR:     break;
        case MO_UTILITIES_TOOLBAR:    break;
        case MO_UTILITIES_STATUSBAR:  break;
        case MO_UTILITIES_DELAYIMAGELOADING:  break;
        case MO_UTILITIES_DISPLAYBACKGROUNDS: break;
      }
  }
  return(button);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static void browser_set_menu_flags(browser *b,menu m,int opt,int button)
{
  if(button!=B_TERM) menu_setflags(m,opt,button_selected(b,button),button_grey(b,button));
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static menu browser_window_menu_maker_f(void *handle)
{
  browser       *b=(browser*)handle;
  wimp_mousestr m;
  HStream       *tp=NULL;

  wimp_get_point_info(&m);
  browser_menu_token=browser_get_pointer_token(b,&m,NULL,NULL);
  if(browser_menu_token) tp=fetch_token_address(b,browser_menu_token);

  browser_set_menu_flags(b,m_file,MO_FILE_SAVE,B_SAVEHTML);
  browser_set_menu_flags(b,m_export,MO_EXPORT_DRAWFILE,B_SAVEDRAW);
  browser_set_menu_flags(b,m_export,MO_EXPORT_PLAINTEXT,B_SAVETEXT);
  browser_set_menu_flags(b,m_navigate,MO_NAVIGATE_OPENURL,B_OPENURL);
  browser_set_menu_flags(b,m_navigate,MO_NAVIGATE_HOMEPAGE,B_HOMEPAGE);
  browser_set_menu_flags(b,m_navigate,MO_NAVIGATE_BACKONEPAGE,B_BACK);
  browser_set_menu_flags(b,m_navigate,MO_NAVIGATE_FORWARDONEPAGE,B_FWD);
  browser_set_menu_flags(b,m_navigate,MO_NAVIGATE_RELOADTHISPAGE,B_RELOAD);
  browser_set_menu_flags(b,m_navigate,MO_NAVIGATE_STOP,B_STOP);
  browser_set_menu_flags(b,m_navigate,MO_NAVIGATE_LOADIMAGES,B_IMAGES);
  browser_set_menu_flags(b,m_hotlist,MO_HOTLIST_GOTOPAGE,B_HOTLIST);
  browser_set_menu_flags(b,m_hotlist,MO_HOTLIST_ADDTHISPAGE,B_ADDHOT);
  browser_set_menu_flags(b,m_hotlist,MO_HOTLIST_REMOVEPAGE,B_SUBHOT);
  browser_set_menu_flags(b,m_hotlist,MO_HOTLIST_SAVE,B_SAVEHOT);
  browser_set_menu_flags(b,m_browse1,MO_BROWSE_RESOURCES,B_RESOURCE);
  browser_set_menu_flags(b,m_utilities,MO_UTILITIES_FINDTEXT,B_FIND);

  menu_setflags(m_export,MO_EXPORT_LINK,FALSE,!(tp && ISLINK(tp)));
  menu_setflags(m_export,MO_EXPORT_PICTURE,FALSE,!((tp && (tp->style&IMG))||b->backimage>0));
  menu_setflags(m_utilities,MO_UTILITIES_TOOLBAR,b->buttonbar.flags&PANE_ISOPEN,FALSE);
  menu_setflags(m_utilities,MO_UTILITIES_URLBAR,b->urlbar.flags&PANE_ISOPEN,FALSE);
  menu_setflags(m_utilities,MO_UTILITIES_STATUSBAR,b->status.flags&PANE_ISOPEN,FALSE);
  menu_setflags(m_utilities,MO_UTILITIES_DELAYIMAGELOADING,b->delayimages,FALSE);
  menu_setflags(m_utilities,MO_UTILITIES_DISPLAYBACKGROUNDS,!b->plainback,FALSE);

  help_register_handler(help_simplehandler,"HmMAIN");
  return(m_browse1);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void browser_window_menu_proc_f(void *handle,char *hit)
{
  browser *b=(browser*)handle;
  int     button;

  button=browser_menu_to_button(b,hit);
  if(button!=B_TERM)
    wimpt_complain(button_press(button,b));
  else
  {
    switch(hit[0])
    {
      case MO_BROWSE_FILE:
        switch(hit[1])
        {
          case MO_FILE_EXPORT:
            switch(hit[2])
            {
              case MO_EXPORT_LINK:      wimpt_complain(fetch_save_link(b,browser_menu_token)); break;
              case MO_EXPORT_PICTURE:   wimpt_complain(image_save_picture(b,browser_menu_token)); break;
            }
          break;
        }
      break;
      case MO_BROWSE_UTILITIES:
        switch(hit[1])
        {
          case MO_UTILITIES_URLBAR:
            b->urlbar.flags^=PANE_ISOPEN;
            b->buttonbar.y0=(b->urlbar.flags&PANE_ISOPEN)?-URLBAR_HEIGHT-4:0;
            wimp_close_wind(b->buttonbar.w);
            wimp_close_wind(b->urlbar.w);
            b->reformat_extent=0;
            reformat_check_extent(b);
            browser_reopen_window(b);
          break;
          case MO_UTILITIES_TOOLBAR:
            b->buttonbar.flags^=PANE_ISOPEN;
            b->buttonbar.y0=(b->urlbar.flags&PANE_ISOPEN)?-URLBAR_HEIGHT-4:0;
            wimp_close_wind(b->buttonbar.w);
            wimp_close_wind(b->urlbar.w);
            b->reformat_extent=0;
            reformat_check_extent(b);
            browser_reopen_window(b);
          break;
          case MO_UTILITIES_STATUSBAR:
            b->status.flags^=PANE_ISOPEN;
            wimp_close_wind(b->status.w);
            b->reformat_extent=0;
            reformat_check_extent(b);
            browser_reopen_window(b);
          break;
          case MO_UTILITIES_DELAYIMAGELOADING:
            b->delayimages=!b->delayimages;
            image_restart_fetches(b);
            button_set_states(b);
          break;
          case MO_UTILITIES_DISPLAYBACKGROUNDS:
            b->plainback=!b->plainback;
            if(b->backimage) browser_update_bottom(b,0);
          break;
        }
      break;
    }
  }
}

/*----------------------------------------------------------------------*/
os_error *browser_new_window_f(browser **handle)
{ /* create a new window and put the address in handle */
  browser        *b;

  *handle=NULL;
  b=malloc(sizeof(browser));
  if(!b) return(errorgen(2));
  memset(b,0,sizeof(browser));
  b->t=template_copy(template_find("viewer"));
  if(!b->t) return(b_e_f(b,errorgen(2)));
  b->t_u=template_copy(template_find("URLbar"));
  if(!b->t_u) return(b_e_f(b,errorgen(2)));
  b->t_b=template_copy(template_find("buttonbar"));
  if(!b->t_b) return(b_e_f(b,errorgen(2)));
  b->t_s=template_copy(template_find("InfoBar"));
  if(!b->t_s) return(b_e_f(b,errorgen(2)));
  b->t->window.scx=b->t->window.scy=0;
  b->t->window.ex.x1=20000;
  b->t->window.ex.y0=-5000;
  b->t->window.title.indirecttext.buffer=b->title;
  b->t->window.title.indirecttext.bufflen=sizeof(b->title);
  ERROUT(b_e_f(b,wimp_create_wind(&b->t->window,&b->w)));
  win_register_event_handler(b->w,browser_window_event,(void*)b);
  if(!event_attachmenumaker(b->w,browser_window_menu_maker_f,browser_window_menu_proc_f,(void*)b))
    return(b_e_f(b,errorgen(2)));
  ERROUT(b_e_f(b,wimp_create_wind(&b->t_b->window,&b->buttonbar.w)));
  b->buttonbar.flags=PANE_LEFTEDGE|PANE_TOPEDGE|PANE_XFREE;
  if(params.toolbar) b->buttonbar.flags|=PANE_ISOPEN;
  b->buttonbar.x0=0;
  b->buttonbar.y0=params.urlbar?-URLBAR_HEIGHT:0;
  b->buttonbar.width=0;
  b->buttonbar.height=BUTTONBAR_HEIGHT;
  win_register_event_handler(b->buttonbar.w,button_event,(void*)b);
  if(!event_attachmenumaker(b->buttonbar.w,browser_window_menu_maker_f,browser_window_menu_proc_f,(void*)b))
    return(b_e_f(b,errorgen(2)));
  ERROUT(b_e_f(b,wimp_create_wind(&b->t_u->window,&b->urlbar.w)));
  b->urlbar.flags=PANE_LEFTEDGE|PANE_TOPEDGE|PANE_XFREE;
  if(params.urlbar) b->urlbar.flags|=PANE_ISOPEN;
  b->urlbar.x0=0;
  b->urlbar.y0=0;
  b->urlbar.width=0;
  b->urlbar.height=URLBAR_HEIGHT;
  win_register_event_handler(b->urlbar.w,button_urlbar_event,(void*)b);
  if(!event_attachmenumaker(b->urlbar.w,browser_window_menu_maker_f,browser_window_menu_proc_f,(void*)b))
    return(b_e_f(b,errorgen(2)));
  ERROUT(b_e_f(b,wimp_create_wind(&b->t_s->window,&(b->status.w))));
  b->status.flags=PANE_LEFTEDGE;
  if(params.statusbar) b->status.flags|=PANE_ISOPEN;
  b->status.x0=0;
  b->status.y0=0;
  b->status.width=0;
  b->status.height=STATUS_HEIGHT;
  win_register_event_handler(b->status.w,status_event,(void*)b);
  if(!event_attachmenumaker(b->status.w,browser_window_menu_maker_f,browser_window_menu_proc_f,(void*)b))
    return(b_e_f(b,errorgen(2)));
  b->next=browser_list;
  browser_list=b;
  *handle=b;
  return(NULL);
}

/*----------------------------------------------------------------------*/
char *browser_history(browser *b)
{
  return((char*)b->hdata);
}

/*----------------------------------------------------------------------*/
char *browser_current_url(browser *b)
{
  if(!b->usize) return(NULL);
  return(((char*)b->hdata)+b->hsize+b->fsize);
}

/*----------------------------------------------------------------------*/
char *browser_fetching_url(browser *b)
{
  if(!b->fsize) return(NULL);
  return(((char*)b->hdata)+b->hsize);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void browser_idle_event(void *handle)
{
  browser *b=(browser*)handle;
  int     events=0; /* events needing to be processed by the idle handler */
  int     animate=0;

#ifdef IDLETRACE
trace_printf("idle:start, stat=%d",b->status_fetch);
#endif
  if(b->status_fetch==BS_START) {events++; wimpt_complain(fetch_start(b));}
  if(fetch_fetching(b))
  {
    events++;
    animate++;
#ifdef IDLETRACE
trace_printf("idle:calling fetcher");
#endif
    fetch_fetcher(b);
#ifdef IDLETRACE
trace_printf("idle:called fetcher");
#endif
  }
  if(reformat_formatting(b))
  {
    events++;
#ifdef IDLETRACE
trace_printf("idle:calling reformatter");
#endif
    reformat_reformatter(b);
#ifdef IDLETRACE
trace_printf("idle:called reformatter");
#endif
    if(!reformat_formatting(b)) reformat_check_extent(b);
  }
  if(image_count_pending(b))
  {
    events++;
    animate++;
#ifdef IDLETRACE
trace_printf("idle:calling image processor");
#endif
    image_process_null(b);
#ifdef IDLETRACE
trace_printf("idle:called image processor");
#endif
  }
  if(b->display_request>0)
  {
#ifdef IDLETRACE
trace_printf("idle:calling showtoken");
#endif
    if(b->display_request==DISPLAY_NAMED)
    {
      int  t;
      char *p;

      t=0;
      p=fetch_find_name_tag(browser_current_url(b));
      t=fetch_find_anchor_token(b,p);
      if(t>0) {b->display_request=t; b->display_request_offset=0;}
    }
    if(b->display_request!=DISPLAY_NAMED)
    {
      if(browser_show_token(b,b->display_request,b->display_request_offset)) b->display_request=0;
    }
#ifdef IDLETRACE
trace_printf("idle:called showtoken");
#endif
  }
  if(!events)
  {
    b->display_request=0;
    idle_deregister_user(browser_idle_event,handle);
  }
  if(animate && events)
    status_animate(b);
  else
    status_set_animation_state(b,0);
  if(!events) button_set_states(b);
#ifdef IDLETRACE
trace_printf("idle:done, stat=%d",b->status_fetch);
#endif
}

/*----------------------------------------------------------------------*/
void browser_use_idle_events(browser *b)
{
  idle_register_user(browser_idle_event,(void*)b,TRUE);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static int browser_time_stamp(void)
{
  return(time(NULL));
}

/*----------------------------------------------------------------------*/
BOOL browser_visited(char *url, BOOL stamp)
{
  char *p;

  p=(char*)global_history;
  if(p)
  {
    char *e;

    e=p+mflex_size(&global_history)-1;
    while(p<e)
    {
      if(!strcmp((p+sizeof(int)),url))
      {
        if(stamp) *(int*)p=browser_time_stamp();
        return(TRUE);
      }
      p+=sizeof(int);
      p+=strlen(p)+1;
      while((int)p&3) p++; /* word aligned */
    }
  }
  return(FALSE);
}

/*----------------------------------------------------------------------*/
os_error * browser_record_global_history_f(char *url)
{ /* put a url in the global history so we know its visited. url must NOT be in a flex block! */
  if(!browser_visited(url,TRUE))
  {
    int  len,oldsize;
    char *n;

    len=strlen(url)+1+sizeof(int);
    while(len&3) len++;
    if(global_history)
    { /* if the global history already exists */
      while(mflex_size(&global_history)>4 &&
            mflex_size(&global_history)+len>params.maxghistory*1024)
      { /* while the history is oversize, delete the oldest entry */
        int  size,oldest=*(int*)global_history;
        char *e,*f=NULL,*p=(char*)global_history;

        e=p+mflex_size(&global_history)-1;
        f=p;
        while(p<e) /* search for the oldest entry */
        {
          if(*(int*)p<oldest) {oldest=*(int*)p; f=p;}
          p+=sizeof(int);
          p+=strlen(p)+1;
          while((int)p&3) p++; /* word aligned */
        }
        size=sizeof(int)+strlen(f+sizeof(int))+1;
        while(size&3) size++;
        memmove(f,f+size,(e-f)-size);
        mflex_extend(&global_history,mflex_size(&global_history)-size);
      }
      oldsize=mflex_size(&global_history);
      if(!mflex_extend(&global_history,oldsize+len)) return(errorgen(2));
    }
    else
    { /* if the history doesn't already exist, create it */
      oldsize=0;
      if(!mflex_alloc(&global_history,len)) return(errorgen(2));
    }
    n=(char*)global_history+oldsize;
    *(int*)n=browser_time_stamp();
    n+=sizeof(int);
    strcpy(n,url);
  }
  return(NULL);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static os_error *browser_record_history_f(browser *b)
{
  if(b->hpos)
  { /* we're in the history at present so truncate it */
    b->hnum=b->hpos;
    b->hpos=0;
    /* don't recover the memory - we'll need it very shortly anyway */
  }
  else if(browser_current_url(b) && *browser_current_url(b))
  {
    int  bytes,count,needed;
    char *p,*last;

    bytes=0;
    p=browser_history(b);
    last=NULL;
    count=b->hnum;
    while(count--)
    {
      int l=strlen(p)+1;

      last=p;
      bytes+=l;
      p+=l;
    }
    if(last && !strcmp(last,browser_current_url(b))) return(NULL);
    needed=strlen(browser_current_url(b))+1; /* space needed to record URL */
    needed-=(b->hsize-bytes); /* subtract free space */
    if(needed>0) /* if we need more space */
    {
      needed=(needed/BLOCKSIZE+1)*BLOCKSIZE; /* round up */
      browser_set_chunk_size_f(b,CK_HIST,b->hsize+needed);
    }
    strcpy(browser_history(b)+bytes,browser_current_url(b));
    b->hnum++;
    while(b->hnum>params.maxvhistory) /* while the history is oversize */
    {
      int  bytes,count;
      char *p;

      bytes=0;
      p=browser_history(b);
      count=b->hnum;
      while(count--) /* count actual useage in block */
      {
        int l=strlen(p)+1;
        bytes+=l;
        p+=l;
      }
      if(b->hsize-bytes>=BLOCKSIZE) /* if there is more than a block free, trim it */
      {
        bytes=(bytes/BLOCKSIZE+1)*BLOCKSIZE;
        browser_set_chunk_size_f(b,CK_HIST,bytes);
      }
      /* delete the oldest entry in the history list */
      bytes=strlen(browser_history(b))+1;
      memmove(browser_history(b),browser_history(b)+bytes,b->hsize-bytes);
      b->hnum--;
    }
  }
  return(NULL);
}

//static os_error *browser_record_history_specific_f(browser *b, char *url)
//{
//  if(b->hpos)
//  { /* we're in the history at present so truncate it */
//    b->hnum=b->hpos;
//    b->hpos=0;
//    /* don't recover the memory - we'll need it very shortly anyway */
//  }
//  else if(url && *url)
//  {
//    int  bytes,count,needed;
//    char *p,*last;
//
//    bytes=0;
//    p=browser_history(b);
//    last=NULL;
//    count=b->hnum;
//    while(count--)
//    {
//      int l=strlen(p)+1;
//
//      last=p;
//      bytes+=l;
//      p+=l;
//    }
//    if(last && !strcmp(last,url)) return(NULL);
//    needed=strlen(url)+1; /* space needed to record URL */
//    needed-=(b->hsize-bytes); /* subtract free space */
//    if(needed>0) /* if we need more space */
//    {
//      needed=(needed/BLOCKSIZE+1)*BLOCKSIZE; /* round up */
//      browser_set_chunk_size_f(b,CK_HIST,b->hsize+needed);
//    }
//    strcpy(browser_history(b)+bytes,url);
//    b->hnum++;
//    while(b->hnum>params.maxvhistory) /* while the history is oversize */
//    {
//      int  bytes,count;
//      char *p;
//
//      bytes=0;
//      p=browser_history(b);
//      count=b->hnum;
//      while(count--) /* count actual useage in block */
//      {
//        int l=strlen(p)+1;
//        bytes+=l;
//        p+=l;
//      }
//      if(b->hsize-bytes>=BLOCKSIZE) /* if there is more than a block free, trim it */
//      {
//        bytes=(bytes/BLOCKSIZE+1)*BLOCKSIZE;
//        browser_set_chunk_size_f(b,CK_HIST,bytes);
//      }
//      /* delete the oldest entry in the history list */
//      bytes=strlen(browser_history(b))+1;
//      memmove(browser_history(b),browser_history(b)+bytes,b->hsize-bytes);
//      b->hnum--;
//    }
//  }
//  return(NULL);
//}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
BOOL browser_display_local_reference(browser *b,char *url_requested,char *url_current)
{ /* check to see if url_requested is a reference to a named anchor inside url_current.
     If it is, scroll the display to show the requested tag and return TRUE.
     Otherwise, return FALSE
   */
  char *p1,*p2;
  char c1,c2;
  BOOL match;

  if(!url_requested || !url_current) return(FALSE);
  p1=fetch_find_name_tag(url_requested);
  if(!p1) return(FALSE);
  p2=fetch_find_name_tag(url_current);
  if(!p2) p2=strchr(url_current,0);
  c1=*p1; c2=*p2;
  *p1=*p2=0;
  match=!strcmp(url_requested,url_current);
  *p1=c1; *p2=c2;
  if(!match) return(FALSE);
  browser_show_named_anchor(b,p1+1);
  return(TRUE);
}

/*----------------------------------------------------------------------*/
BOOL browser_display_local_reference_quietly(browser *b,char *url_requested,char *url_current)
{ /* check to see if url_requested is a reference to a named anchor inside url_current.
     If it is, scroll the display to show the requested tag and return TRUE.
     Otherwise, return FALSE
   */
  char *p1,*p2;
  char c1,c2;
  BOOL match;

  if(!url_requested || !url_current) return(FALSE);
  p1=fetch_find_name_tag(url_requested);
  if(!p1) return(FALSE);
  p2=fetch_find_name_tag(url_current);
  if(!p2) p2=strchr(url_current,0);
  c1=*p1; c2=*p2;
  *p1=*p2=0;
  match=!strcmp(url_requested,url_current);
  *p1=c1; *p2=c2;
  if(!match) return(FALSE);
  return (browser_show_named_anchor_quietly(b,p1+1));
}
/*----------------------------------------------------------------------*/
os_error *browser_show_url_f(browser *b,char *url,BOOL record)
{ /* the 'record' parameter says whether to record the previous URL in the history
     list. Set to FALSE by the 'forward' and 'back' options, otherwise
     TRUE which truncates the history at the current position if we're in
     the history list or adds the current URL to the list if we're not. */
  os_error *e=NULL;
  int      len;
  char     *tempurl;

  len=strlen(url);
  tempurl=malloc(len+1);
  if(!tempurl) return(errorgen(2));
  strcpy(tempurl,url);

  if (record && browser_current_url(b) && strcmp(tempurl, browser_current_url(b)))
    browser_record_history_f(b); /* ignore errors */

  if(!b->savelink && browser_display_local_reference(b,url,browser_current_url(b)))
  {
    browser_record_global_history_f(tempurl);
    free(tempurl);
    return(NULL);
  }

  b->ptr_link=0;
  browser_stop_f(b,TRUE);
  e=browser_set_chunk_size_f(b,CK_FURL,WORDALIGN(len+1));
  if(!e) strcpy(browser_fetching_url(b),tempurl);
  if(!e) b->status_fetch=BS_START;
  free(tempurl);
  if(e)
  {
    e=errorgen((int)e);
    /* ;{{ tidy up after error so window can still be redrawn etc */
  }
  browser_use_idle_events(b);
  if(e || !len)
  {
    sprintf(b->title,msgs_lookup("BLANK:Blank page"));
    browser_set_chunk_size_f(b,CK_DURL,0);
    browser_redraw_title(b);
    browser_stop_f(b,TRUE);
    /* ;{{ special case for blank URL - make sure its still right */
  }
  status_new_status(b);
  status_show_progress(b);
  button_set_states(b);
  return(e);
}

/*----------------------------------------------------------------------*/
os_error *browser_new_view_f(char *url)
{
  browser      *b,*p;
  wimp_openstr o;
  int          count,width,height,mask;
  os_error     *e;

  ERROUT(browser_new_window_f(&b));
  b->delayimages=params.delayimages;
  b->plainback=!params.displaybgs;
  b->bytes_fetched=-1;
  count=-1; p=browser_list; while(p) {count++; p=p->next;} /* count of windows open - 1 */
  width=bbc_modevar(-1,11)*Wimpt_dx; /* actual screen size */
  height=bbc_modevar(-1,12)*Wimpt_dy;
  o.w=b->w;
  o.box.x1=DEFAULT_WIDTH;
  if(o.box.x1>width-64) o.box.x1=width-64;
  o.box.y1=DEFAULT_HEIGHT;
  if(o.box.y1>height-128) o.box.y1=height-128;
  o.box.x0=(width-o.box.x1)/2-20; /* centred on screen and offset by count */
  o.box.y0=(height-o.box.y1)/2-count*32;
  o.box.x1+=o.box.x0;
  o.box.y1+=o.box.y0;
  o.x=0;
  o.y=512; /* scrolled top top left */
  o.behind=-1;
  ERROUT(b_e_f(b,pane_open_window(&o,&b->buttonbar)));
  ERROUT(b_e_f(b,button_set_states(b)));
  b->display_width=browser_display_width(b);
  mask=event_getmask();
  event_setmask((wimp_emask) (mask&~wimp_EMNULL));
  event_process();
  event_setmask((wimp_emask) (mask&~wimp_EMNULL));
  event_process();
  event_setmask((wimp_emask) (mask&~wimp_EMNULL));
  event_process();
  e=browser_show_url_f(b,"",FALSE);
  if(!e) e=browser_show_url_f(b,url,FALSE);
  if(e) e=errorgen((int)e);
  browser_give_focus_general(b);
  button_set_states(b);
  return(e);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static char * browser_translate_pathname(char *s)
{
  char *p;

  p=s;
  while(*p && *p!=':') p++;
  while(*p)
  {
    if(*p=='/') *p='.'; else if(*p=='.') *p='/';
    p++;
  }
  return(s);
}

/*----------------------------------------------------------------------*/
char *browser_pathname_to_url(char *path,int size)
{
  int ml;

  ml=strlen(FILEMETHOD);
/*trace_printf("%d:%s",ml,FILEMETHOD);*/
/*trace_printf(path);*/
  if(ml_strncmpi(path,FILEMETHOD,ml))
  {
    memmove(path+ml,path,size-ml);
    strncpy(path,FILEMETHOD,ml);
    path[size-1]=0;
/*trace_printf(path);*/
    browser_translate_pathname(path+ml);
/*trace_printf(path);*/
  }
/*trace_printf("----");*/
  return(path);
}

/*----------------------------------------------------------------------*/
void browser_fix_url(char *buffer,int bufsize)
{
  if(!strchr(buffer,':') && strlen(buffer)<bufsize-7)
  {
    memmove(buffer+7,buffer,bufsize-7);
    strncpy(buffer,"http://",7);
    buffer[bufsize-1]=0;
  }
  if(strlen(buffer)<bufsize-2 && !ml_strncmpi(buffer,"http:",5))
  {
    int i,s;

    s=0;
    for(i=0;!s && buffer[i] && i<bufsize-1;i++)
      if(buffer[i]=='/' && buffer[i+1]!='/') s=1; else if(buffer[i]=='/') i++;
    if(!s) strcat(buffer,"/");
  }
}

/*----------------------------------------------------------------------*/
os_error *browser_open_location(browser *b,BOOL file)
{
  dbox d;
  char defval[512];
  int  f,ml;

  d=dbox_new("getloc");
  ml=strlen(FILEMETHOD);
  if(!d) return(errorgen(2));
  dbox_raw_eventhandler(d,help_dboxrawevents,"HdGETLOC");
  if(file)
    dbox_setfield(d,2,msgs_lookup("GETFIL:Please enter pathname of file to display:"));
  else
    dbox_setfield(d,2,msgs_lookup("GETLOC:Please enter URL to display:"));
  button_set_flags(b,file?B_OPENFILE:B_OPENURL,TRUE,FALSE);
  dbox_show(d);
  do
  {
    defval[0]=0;

    if (browser_current_url(b))
    {
      STRFILL(defval,browser_current_url(b));
    }
    else STRFILL(defval,params.homepage);

    if(!*defval) STRFILL(defval,browser_fetching_url(b));
    if(file)
    {
      if(ml_strncmpi(defval,FILEMETHOD,ml))
        defval[0]=0;
      else
         memmove(defval,defval+ml,sizeof(defval)-ml);
    }
    dbox_setfield(d,3,defval);
    f=dbox_fillin(d);
    if(f==0)
    {
      dbox_getfield(d,3,defval,sizeof(defval));
      if(defval[0])
      {
      if(file)
        browser_pathname_to_url(defval,sizeof(defval));
      else
        browser_fix_url(defval,sizeof(defval));
      wimpt_complain(browser_show_url_f(b,defval,TRUE));
      }
    }
  } while(f!=dbox_CLOSE && ((f!=0 && f!=1) || dbox_persist()));
  dbox_dispose(&d);
  button_set_flags(b,file?B_OPENFILE:B_OPENURL,FALSE,FALSE);
  return(NULL);
}

/*----------------------------------------------------------------------*/
os_error *browser_forward_f(browser *b)
{
  if(b->hpos>0 && b->hpos<b->hnum)
  {
    int  count;
    char *p;

    count=++b->hpos;
    if(b->hpos>=b->hnum)
      {
      b->hpos=0;
      if(b->hnum>0) b->hnum--; /* remove the last entry from the list so 'back' won't go to it */
      }
    p=browser_history(b);
    while(--count) p+=strlen(p)+1;
    return(browser_show_url_f(b,p,FALSE));
  }
  return(NULL);
}

/*----------------------------------------------------------------------*/
os_error *browser_back_f(browser *b)
{
  if((b->hpos>1 || b->hpos==0) && b->hnum)
  {
    int  count;
    char *p;

    if(b->hpos==0)
    {
      os_error *e;

      count=b->hnum;
      e=browser_record_history_f(b);
      count=b->hnum-1;
      if(count<1) count=1;
      b->hpos=count;
    }
    else count=--b->hpos;
    p=browser_history(b);
    while(--count>0) p+=strlen(p)+1;
    return(browser_show_url_f(b,p,FALSE));
  }
  return(NULL);
}

/*----------------------------------------------------------------------*/
os_error *browser_stop_f(browser *b,BOOL urgent)
{
  urgent=urgent;
  fetch_cancel(b);
  return(NULL);
}

/*----------------------------------------------------------------------*/
os_error *browser_stop_all_f(BOOL urgent)
{
  browser *b;

  b=browser_list;
  while(b)
  {
    browser_stop_f(b,urgent);
    b=b->next;
  }
  return(NULL);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void browser_find_match(browser *b,char *pattern,BOOL casematch,BOOL fromstart)
{
  int                 tnStart=0,tnCurrent=0; /* token numbers */
  int                 ofStart,ofCurrent; /* offsets within tokens */
  int                 lnCurrent; /* length of text on current token */
  HStream             *tpCurrent;
  char                *tdCurrent; /* data for current token */
  int                 ofPat; /* offset into pattern of where we've matched to */
  char                cp,ct; /* characters from pattern and from text */
  BOOL                found,done,cond;

  found=FALSE;
  ofStart=ofCurrent=0;
  if(b->nlines>=1)
  {
    if (fromstart)
    {
      reformat_line       *lp;
      reformat_line_chunk *cp;

      lp=reformat_line_address(b,1);
      cp=reformat_line_chunk_address(lp,0);
      tnCurrent=cp->t;
      ofCurrent=cp->o-1; /* -1 because the first thing in the loop increments this */
    }
    else
    {
      reformat_line       *lp;
      reformat_line_chunk *cp;
      int                 t;

      t=browser_top_line(b)+1;
      lp=reformat_line_address(b,t);
      cp=reformat_line_chunk_address(lp,0);
      tnCurrent=cp->t;
      ofCurrent=cp->o-1; /* -1 because the first thing in the loop increments this */
    }
    tpCurrent=fetch_token_address(b,tnCurrent);
    tdCurrent=fetch_token_data_address(b,tnCurrent);
    lnCurrent=tdCurrent?strlen(tdCurrent)-1:-1;  /* minus 1 because comparison precedes increment */
    ofPat=0;
    cp=pattern[0];
    if(!casematch) cp=toupper(cp);
    ofStart=tnStart=-1;
    done=FALSE;
    do
    {
      do
      {
        /* Merlyn had this to say about the following code that he wrote:            */
        /*                                                                           */
        /* don't ask me why I've had to introduce the cond variable and change my    */
        /* nice neat while loop into a strange series of conditionals. It's the only */
        /* way this good-for-nothing compiler would generate useful object           */

        cond=ofCurrent>=lnCurrent;
        if(!cond) cond = ((tpCurrent->style&(IMG|HR|INPUT|SELECT|TEXTAREA)) | (ISHEAD(tpCurrent)));
        cond=cond && !done;
        if(cond)
        {
          if((tpCurrent->style&(IMG|HR|INPUT|SELECT|TEXTAREA)) || (ISHEAD(tpCurrent)))
          {
            ofPat=0; /* dont allow pattern to cross non-text tokens */
            cp=pattern[0];
            if(!casematch) cp=toupper(cp);
          }
          tnCurrent++;
          if(tnCurrent<=b->ntokens)
          {
            tpCurrent=fetch_token_address(b,tnCurrent);
            tdCurrent=fetch_token_data_address(b,tnCurrent);
            lnCurrent=tdCurrent?strlen(tdCurrent)-1:-1; /* minus 1 because comparison precedes increment */
            ofCurrent=-1; /* so the up-coming increment will put us on the first character, at 0 */
          }
          else
            done=TRUE; /* fallen off the end */
        }
      } while(cond);
      if(!done)
      {
        int ofPPrev;

        ofPPrev=ofPat;
        ofCurrent++;
        ct=tdCurrent[ofCurrent];
        if(ct=='\n') ct=' ';
        if(!casematch) ct=toupper(ct);
        if(ct==cp)
        {
          if(!ofPat)
          {
            ofStart=ofCurrent;
            tnStart=tnCurrent;
          }
          ofPat++;
        }
        else
        {
          if(ofPat)
          {
            ofPat=0;
            ofCurrent=ofStart;
            tnCurrent=tnStart;
            tpCurrent=fetch_token_address(b,tnCurrent);
            tdCurrent=fetch_token_data_address(b,tnCurrent);
          }
        }
        if(ofPat!=ofPPrev)
        {
          cp=pattern[ofPat];
          if(!casematch) cp=toupper(cp);
          if(!cp) found=TRUE;
        }
      }
    } while(!done && !found);
  }
  if(found)
    browser_show_token(b,tnStart,ofStart);
  else
    bbc_vdu(7);
}

/*----------------------------------------------------------------------*/
os_error *browser_find(browser *b)
{
  dbox d;
  int  f;
  char pattern[sizeof(user.lastfind)];

  d=dbox_new("find");
  if(!d) return(errorgen(2));
  dbox_raw_eventhandler(d,help_dboxrawevents,"HdFIND");
  button_set_flags(b,B_FIND,TRUE,FALSE);
  STRFILL(pattern,user.lastfind);
  dbox_show(d);
  do
  {
    dbox_setfield(d,2,pattern);
    dbox_setnumeric(d,6,user.casematch);
    f=dbox_fillin(d);
    if(f==0 || f==5)
    {
      dbox_getfield(d,2,pattern,sizeof(pattern));
      user.casematch=dbox_getnumeric(d,6);
      if(pattern[0])
      {
        STRFILL(user.lastfind,pattern);
        browser_find_match(b,pattern,user.casematch,f==0);
      }
    }
  } while(f!=dbox_CLOSE && (f!=1 || dbox_persist()));
  dbox_dispose(&d);
  button_set_flags(b,B_FIND,FALSE,FALSE);
  return(NULL);
}

/*----------------------------------------------------------------------*/
os_error *browser_print(browser * b)
{
  return print_dbox(b);
}

/*----------------------------------------------------------------------*/
os_error *browser_set_all_button_states(void)
{
  browser *b;

  b=browser_list;
  while(b)
  {
    button_set_states(b);
    b=b->next;
  }
  return(NULL);
}

/*----------------------------------------------------------------------*/
os_error *browser_update_all_status_text(void)
{ /* update the status text for the all browsers */
  browser *b;

  b=browser_list;
  while(b)
  {
    status_update_text(b);
    b=b->next;
  }
  return(NULL);
}

/*----------------------------------------------------------------------*/
os_error *browser_update_all(void)
{ /* update all browsers */
  browser        *b;
  wimp_redrawstr r;

  b=browser_list;
  while(b)
  {
    r.box.x0=r.box.y0=-2000000000;
    r.box.x1=r.box.y1=2000000000;
    browser_update(b,&r,FALSE);
    status_update_all(b);
    b=b->next;
  }
  return(NULL);
}

/*----------------------------------------------------------------------*/
os_error *browser_reformat_all(void)
{
  browser *b;

  b=browser_list;
  while(b)
  {
    reformat_format_from(b,0);
    b=b->next;
  }
  return(NULL);
}

/*----------------------------------------------------------------------*/
void browser_save_history(void)
{
  char command[sizeof(user.historyfile)+32];

  sprintf(command,"Save %s %p +%x",user.historyfile,global_history,mflex_size(&global_history));
  os_cli(command);
}

/*----------------------------------------------------------------------*/
void browser_lose_history(void)
{
  if(global_history)
  {
    mflex_free(&global_history);
    global_history=NULL;
  }
  if(authorise)
  {
    mflex_free(&authorise);
    authorise=NULL;
  }
}

/*----------------------------------------------------------------------*/
void browser_load_history(void)
{
  browser_lose_history();
  load_file_into_flex(user.historyfile,&global_history);
}

/*----------------------------------------------------------------------*/
os_error *browser_mode_change(void)
{
  browser *b;

  b=browser_list;
  while(b)
  {
    image_mode_change(b);
    browser_reopen_window(b);
    reformat_format_from(b,0);
    b=b->next;
  }
  return(NULL);
}

/*----------------------------------------------------------------------*/
void browser_highlight_token(browser *b,int token)
{
  browser_clear_highlight(b,FALSE);
  b->highlight=token;
  browser_update_token(b,token,FALSE);
}

/*----------------------------------------------------------------------*/
void browser_clear_highlight(browser *b,BOOL wait)
{
  if(b->highlight)
  {
    int token;

    token=b->highlight;
    b->highlight=0;
    if(wait) bbc_inkey(20);
    browser_update_token(b,token,FALSE);
  }
}

/*----------------------------------------------------------------------*/
void browser_flash_token(browser *b,int token)
{
  browser_highlight_token(b,token);
  browser_clear_highlight(b,TRUE);
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static int browser_authorise_offset(char *host,char *realm)
{ /* get the offset of the username for the realm and host or -1 */
  int  o,s,l;
  char *h,*r;

  if(authorise)
  {
    h=(char*)authorise; /* first host in list */
    o=0;
    s=mflex_size(&authorise);
    while(o<s)
    {
      l=strlen(h)+1;
      r=h+l; /* pointer to realm */
      if(!strcmp(h,host) && !strcmp(r,realm)) return(o);
      o+=l; l=strlen(r)+1; o+=l;
      r+=l; l=strlen(r)+1; o+=l;
      r+=l; l=strlen(r)+1; o+=l;
      h=r+l;
    }
  }
  return(-1);
}

/*----------------------------------------------------------------------*/
char *browser_authorise_username(char *host,char *realm)
{
  int  o;
  char *p;

  o=browser_authorise_offset(host,realm);
  if(o<0) return(NULL);
  p=((char*)authorise)+o;
  p+=strlen(p)+1; /* skip over host */
  p+=strlen(p)+1; /* skip over realm */
  return(p);
}

/*----------------------------------------------------------------------*/
char *browser_authorise_password(char *host,char *realm)
{
  int  o;
  char *p;

  o=browser_authorise_offset(host,realm);
  if(o<0) return(NULL);
  p=((char*)authorise)+o;
  p+=strlen(p)+1; /* skip over host */
  p+=strlen(p)+1; /* skip over realm */
  p+=strlen(p)+1; /* skip over username */
  return(p);
}

/*----------------------------------------------------------------------*/
void browser_authorise_forget(char *host,char *realm)
{
  int o;

  o=browser_authorise_offset(host,realm);
  if(o>=0)
  {
    char *p;
    int  l,s,n;

    s=mflex_size(&authorise);
    n=0;
    p=((char*)authorise)+o;
    l=strlen(p)+1; n+=l; p+=l;
    l=strlen(p)+1; n+=l; p+=l;
    l=strlen(p)+1; n+=l; p+=l;
    l=strlen(p)+1; n+=l; p+=l;
    if(n>=s)
    {
      mflex_free(&authorise);
      authorise=NULL;
    }
    else
    {
      memmove(((char*)authorise)+o,((char*)authorise)+o+n,s-o-n);
      mflex_extend(&authorise,s-n);
    }
  }
}

/*----------------------------------------------------------------------*/
os_error *browser_authorise_remember(char *host,char *realm,char *username,char *password)
{
  int  s,n,ok;
  char *p;

  browser_authorise_forget(host,realm);
  n=strlen(host)+1+strlen(realm)+1+strlen(username)+1+strlen(password)+1;
  if(authorise) s=mflex_size(&authorise); else s=0;
  if(s) ok=mflex_extend(&authorise,s+n); else ok=mflex_alloc(&authorise,n);
  if(!ok) return(errorgen(2));
  p=((char*)authorise)+s;
  sprintf(p,"%s",host); p+=strlen(p)+1;
  sprintf(p,"%s",realm); p+=strlen(p)+1;
  sprintf(p,"%s",username); p+=strlen(p)+1;
  sprintf(p,"%s",password); p+=strlen(p)+1;
  return(NULL);
}

/*----------------------------------------------------------------------*/
os_error *browser_reload(browser *b)
{
  os_error *e;

  e=browser_show_url_f(b,browser_current_url(b),FALSE);
  if(!e) b->reloading=TRUE;
  return(e);
}

