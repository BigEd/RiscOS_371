
#if 0

    Library of various graphics routines. Merlyn Kline 1992

:NOTES

  This library uses wimp_box structures which are assumed to be
  top-right exclusive and bottom-left inclusive.

  The routines graphics_clip_boxes() and graphics_combine_boxes()
  can be used to make many redraw/update routines more efficient.
  Recommended calling procedure to see whether two boxes can be
  more efficiently rendered as one is:

    if(graphics_clip_boxes(box1,box2)!=1) graphics_combine_boxes(box1,box2);
    if(box1->x0!=box1->x1) {/* update box1*/}
    if(box2->x0!=box2->x1) {/* update box2*/}

  If you want to maintain a list of boxes to be updated and add new boxes
  to the list, combining or clipping them where appropriate, you could
  keep a box list in an array like:

    wimp_box boxes[LISTSIZE];

  and then use a routine like the following to update it. Note that this
  routine trades speed against completeness. Since it scans the list for
  each new box and changes the entries in the list, it is possible for
  the list to end up containing two entries which could be combined or
  clipped for more efficient rendering. The likelihood of this depends on
  the nature of the rectangles generated by the client but in general is
  not very high. Note also that the box pointed to by the parameter may be
  modified. The list should be initialised by setting all entries to zero.

    BOOL add_box_to_list(wimp_box *box)
    {
    int      i;

    graphics_sort_box(box); /* not necessary if client always provides sorted boxes */
    for(i=0;i<LISTSIZE;i++) /* check the whole list */
      {
      if(boxes[i].x0!=boxes[i].x1 &&           /* if its a valid entry */
         graphics_clip_boxes(&boxes[i],box))   /* and it can be clipped */
        {
        if(box->x0==box->x1)          /* if input box was clipped to nothing */
          break;                      /* then we're done */
        }
      }
    if(i>=LISTSIZE)   /* if we didn't clip input box to nothing */
      {
      for(i=0;i<LISTSIZE;i++) /* check the whole list again */
        {
        if(boxes[i].x0!=boxes[i].x1 &&             /* if its a valid entry */
           graphics_combine_boxes(&boxes[i],box))  /* and it can be combined */
          break;                                   /* we're done */
        }
      if(i>=LISTSIZE)  /* if we didn't find an entry to combine */
        {
        for(i=0;i<LISTSIZE;i++)  /* check the whole list again */
          {
          if(boxes[i].x0==boxes[i].x1)  /* if this entry is unused */
            {
            boxes[i]=*box;              /* then use it */
            break;
            }
          }
        }
      }
    return(i<LISTSIZE); /* return flag indicating success */
    }

:END

:MESSAGES
:END

:HISTORY
    19/08/93  MK  Added header info (ie this text etc)
    06/09/93  MK  Added graphics_clip_box
    06/09/93  MK  Added graphics_clip_boxes
    06/09/93  MK  Added graphics_sort_box
:END

#endif

#include "stddef.h"
#include "string.h"
#include "resspr.h"

#include "wimpt.h"
#include "os.h"
#include "sprite.h"
#include "colourtran.h"
#include "bbc.h"

#include "Browser.h"
#include "Printing.h"

/*------------------------------------------------------------------------*/
#include "coords.h"

/* ----------------------------------------------------------------------
   mode/co-ord management stuff
   ---------------------------------------------------------------------- */

static int graphics__xmask=-1;  /* & mask for x co-ordinates */
static int graphics__ymask=-1;  /* & mask for y co-ordinates */
static sprite_pixtrans graphics__pxt[256]; /* global store for MODE translate */
static sprite_factors  graphics__fct;      /* global store for MODE translate */

/*------------------------------------------------------------------------*/
int graphics_checkmode(BOOL force)
{
static int currentmode=-1;
int        mode;

wimpt_checkmode();
mode=wimpt_mode();
if(mode!=currentmode || force)
  {
  sprite_id  sprite;

  graphics__ymask=~(Wimpt_dy-1);
  graphics__xmask=~(Wimpt_dx-1);
  sprite.tag=sprite_id_name;
  sprite.s.name="!app";
  wimp_readpixtrans(resspr_area(),&sprite,&graphics__fct,graphics__pxt);
  }        
return(currentmode=mode);
}

/*------------------------------------------------------------------------*/
sprite_factors *graphics_factors(void)
{
return(&graphics__fct);
}

/*------------------------------------------------------------------------*/
sprite_pixtrans *graphics_pixtrans(void)
{
return(graphics__pxt);
}

/*------------------------------------------------------------------------*/
int graphics_xmask(void)
{
return(graphics__xmask);
}

/*------------------------------------------------------------------------*/
int graphics_ymask(void)
{
return(graphics__ymask);
}

/* ----------------------------------------------------------------------
   colour stuff
   ---------------------------------------------------------------------- */

/*------------------------------------------------------------------------*/
void graphics_set_invert_colour(void)
{
if(wimpt_bpp()==8)
  {
  int              black,white,gcol;
  wimp_paletteword col;

  col.word=0xFFFFFF00;
  colourtran_return_colournumber(col,&white);
  col.word=0x00000000;
  colourtran_return_colournumber(col,&black);
  white^=black;
  colourtran_colournumbertoGCOL(white,&gcol);
  bbc_gcol(3,(gcol>>2)&0x3f);
  bbc_tint(2,gcol&3);
  }
else
  wimp_setcolour(7+(3<<4));
}

/* ----------------------------------------------------------------------
   window/coord stuff
   these functions work as per coords_ but don't take a pointer to a
   conversion structure. Instead, the structure is registered by one
   of a new set of routines which takes an openstr*, a redrawstr* or
   simply a window handle.
   ---------------------------------------------------------------------- */

static coords_cvtstr graphics__cvt;

/*------------------------------------------------------------------------*/
void graphics_c_register_cvtstr(coords_cvtstr *c)
{
graphics__cvt=*c;
}

/*------------------------------------------------------------------------*/
#define graphics_c_register_openstr(o)\
  graphics_c_register_cvtstr((coords_cvtstr*)&(o)->box)

/*------------------------------------------------------------------------*/
#define graphics_c_register_redrawstr(r)\
  graphics_c_register_cvtstr((coords_cvtstr*)&(r)->box)

/*------------------------------------------------------------------------*/
int graphics_c_x_toscreen(int x)
{return(x-graphics__cvt.scx+graphics__cvt.box.x0);}

/*------------------------------------------------------------------------*/
int graphics_c_y_toscreen(int y)
{return(y-graphics__cvt.scy+graphics__cvt.box.y1);}

/*------------------------------------------------------------------------*/
int graphics_c_x_toworkarea(int x)
{return(x+graphics__cvt.scx-graphics__cvt.box.x0);}

/*------------------------------------------------------------------------*/
int graphics_c_y_toworkarea(int y)
{return(y+graphics__cvt.scy-graphics__cvt.box.y1);}

/*------------------------------------------------------------------------*/
void graphics_c_box_toscreen(wimp_box *b)
{
b->x0=graphics_c_x_toscreen(b->x0);
b->y0=graphics_c_y_toscreen(b->y0);
b->x1=graphics_c_x_toscreen(b->x1);
b->y1=graphics_c_y_toscreen(b->y1);
}

/*------------------------------------------------------------------------*/
void graphics_c_box_toworkarea(wimp_box *b, coords_cvtstr *cvt)
{
b->x0=graphics_c_x_toworkarea(b->x0);
b->y0=graphics_c_y_toworkarea(b->y0);
b->x1=graphics_c_x_toworkarea(b->x1);
b->y1=graphics_c_y_toworkarea(b->y1);
}

/*------------------------------------------------------------------------*/
void graphics_c_point_toscreen(coords_pointstr *point)
{
point->x=graphics_c_x_toscreen(point->x);
point->y=graphics_c_y_toscreen(point->y);
}

/*------------------------------------------------------------------------*/
void graphics_c_point_toworkarea(coords_pointstr *point)
{
point->x=graphics_c_x_toworkarea(point->x);
point->y=graphics_c_y_toworkarea(point->y);
}


/*------------------------------------------------------------------------*/
BOOL graphics_combine_boxes(wimp_box *box1,wimp_box *box2)
{
/* Compare box1 with box2 and combines into box1 (zeroing box2) if the area
   of the combined box is not much more than the total area covered by the
   two boxes. Return a flag indicating whether combination took place.
   box1 and box2 must be sorted (ie x0,y0 in lower left). Check by calling
   graphics_sort_box().
*/
wimp_box combined;
int      wc,hc,w1,h1,w2,h2;

combined.x0=box1->x0<box2->x0?box1->x0:box2->x0;
combined.x1=box1->x1>box2->x1?box1->x1:box2->x1;
combined.y0=box1->y0<box2->y0?box1->y0:box2->y0;
combined.y1=box1->y1>box2->y1?box1->y1:box2->y1;
wc=combined.x1-combined.x0;
hc=combined.y1-combined.y0;
w1=box1->x1-box1->x0;
h1=box1->y1-box1->y0;
w2=box2->x1-box2->x0;
h2=box2->y1-box2->y0;
while(wc>16383 || hc>16383)
 {
 wc=wc>>1; hc=hc>>1;
 w1=w1>>1; h1=h1>>1;
 w2=w2>>1; h2=h2>>1;
 }
if(wc*hc<((w1*h1*6)/5+(w2*h2*6)/5))
  {
  *box1=combined;
  memset(box2,0,sizeof(wimp_box));
  return(TRUE);
  }
return(FALSE);
}                                 

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
BOOL graphics__point_in_box(int x,int y,wimp_box *box)
{
/* Check to see if point is inside box. Box must be sorted */
return(x>=box->x0 && x<=box->x1 && y>=box->y0 && y<=box->y1);
}

/*------------------------------------------------------------------------*/
BOOL graphics_sort_box(wimp_box *box)
{
/* Check that the box has x0,y0 in lower left. If not fix it.
   returns a flag saying if anything was done */
BOOL v=FALSE;

if(box->x0>box->x1)
  {
  int t;

  t=box->x0;
  box->x0=box->x1;
  box->x1=t;
  v=TRUE;
  }
if(box->y0>box->y1)
  {
  int t;

  t=box->y0;
  box->y0=box->y1;
  box->y1=t;
  v=TRUE;
  }
return(v);
}

/*------------------------------------------------------------------------*/
int graphics_clip_box(wimp_box *box1,wimp_box *box2)
{
/* Check to see if box1 can be trimmed because all or part of it lies
   inside box2. Uses the premise that if two or more corners of box1
   are inside box2 then this can be done. If box1 is entirely inside
   box2 then it will be set entirely to zero. box1 and box2 must be
   sorted (ie x0,y0 in lower left). Check by calling graphics_sort_box().

   Returns a flag indicating if any change was made to box1:
       0=no change
       1=box1 was set to zero
       2=box1 was altered
*/
char corner[4];

corner[0]=graphics__point_in_box(box1->x0,box1->y0,box2);
corner[2]=graphics__point_in_box(box1->x1,box1->y1,box2);
if(corner[0] && corner[2])
  { /* box1 is entirely inside box2 so kill it */
  memset(box1,0,sizeof(wimp_box));
  return(1);
  }
corner[1]=graphics__point_in_box(box1->x0,box1->y1,box2);
corner[3]=graphics__point_in_box(box1->x1,box1->y0,box2);
if(corner[0])
  {
  if(corner[1])
    {
    box1->x0=box2->x1;
    return(2);
    }
  if(corner[3])
    {
    box1->y0=box2->y1;
    return(2);
    }
  }
if(corner[2])
  {
  if(corner[1])
    {
    box1->y1=box2->y0;
    return(2);
    }
  if(corner[3])
    {
    box1->x1=box2->x0;
    return(2);
    }
  }
return(0);
}

/*------------------------------------------------------------------------*/
int graphics_clip_boxes(wimp_box *box1,wimp_box *box2)
{
/* Check to see if box1 or box2 can be trimmed due to overlap.
   box1 and box2 must be sorted (ie x0,y0 in lower left). Check by calling
   graphics_sort_box().

   Returns a flag indicating if any change was made:
     0=no change
     1=one box was zeroed
     2=altered
*/
int t;

t=graphics_clip_box(box1,box2);
if(t) return(t);
return(graphics_clip_box(box2,box1));
}

/*------------------------------------------------------------------------*/
os_error *graphics_rectanglefill(int x,int y,int w,int h)
{
/* as per bbc_rectanglefill() but avoiding os unit overflows */
/* nb: +ve w,h only */
if(x<0) {w+=x; x=0;}
if(y<0) {h+=y; y=0;}
if(w>20000) w=20000;
if(h>20000) h=20000;
if(w>0 && h>0 && x<20000 && y<20000) bbc_rectanglefill(x,y,w,h);
return(NULL);
}

/*=============================================================================*/
#if 0

  /* Test code follows. Change the 0 (above) to a 1 to compile this
     code.
  */

#include "stdlib.h"

int r(int max)
{
return(rand()/(RAND_MAX/max));
}

int main(void)
{
wimp_box box1,box2;
bbc_mode(12);
do
  {
  bbc_cls();
  box1.x0=r(640);
  box1.x1=r(640);
  box1.y0=r(512);
  box1.y1=512+r(512);
  box2.x0=r(640);
  box2.x1=r(640);
  box2.y0=r(512);
  box2.y1=512+r(512);
  bbc_gcol(0,2);
  bbc_rectangle(box1.x0,box1.y0,box1.x1-box1.x0-1,box1.y1-box1.y0-1);
  bbc_gcol(0,3);
  bbc_rectangle(box2.x0,box2.y0,box2.x1-box2.x0-1,box2.y1-box2.y0-1);

  graphics_sort_box(&box1);
  graphics_sort_box(&box2);

  if(graphics_clip_boxes(&box1,&box2)!=1) graphics_combine_boxes(&box1,&box2);

  bbc_gcol(0,1);
  bbc_move(box1.x0,box1.y0);
  bbc_draw(box1.x1-1,box1.y1-1);
  bbc_move(box1.x1-1,box1.y0);
  bbc_draw(box1.x0,box1.y1-1);
  bbc_move(box2.x0,box2.y0);
  bbc_draw(box2.x1-1,box2.y1-1);
  bbc_move(box2.x1-1,box2.y0);
  bbc_draw(box2.x0,box2.y1-1);
  } while(bbc_get()==32);
}

#endif
