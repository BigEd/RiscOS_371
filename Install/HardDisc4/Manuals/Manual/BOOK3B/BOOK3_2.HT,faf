<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE></TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME=HEADING2> </A>
<A HREF="BOOK3_3.HT"><IMG ALIGN=BOTTOM SRC="next" WIDTH=69 HEIGHT=24></A> <A HREF="../BOOK2AB/E_18.HTM"><IMG ALIGN=BOTTOM SRC="prev" WIDTH=69 HEIGHT=24></A> <A HREF="../BOOKB/USERGUIDE"><IMG ALIGN=BOTTOM SRC="top" WIDTH=69 HEIGHT=24></A> <A HREF="../BOOKB/TOC.HTM"><IMG ALIGN=BOTTOM SRC="content" WIDTH=69 HEIGHT=24> </A><A HREF="../INDEX/MAIN.HTM"><IMG ALIGN=BOTTOM SRC="index" WIDTH=69 HEIGHT=24></A><P>
RISC OS 3.7 User Guide<P>
<A NAME=HEADING2-0> </A>
<H1></H1>
<HR>
<A NAME=HEADING1-0> </A>
<H1>Appendix A</B>:  <A NAME=MARKER-9-1> </A>The command line</H1>
<HR>
<P>
Usually you will use the RISC OS desktop for almost all of your computing tasks. However occasionally you may need to use the <A NAME=MARKER-2-2> </A>command line. <P>
The command line is very different from the desktop. Gone are the windows, icons and menus. These are replaced by a set of single line commands that always start with a star, the Star Commands (known as *commands).<P>
All the commands are described, in alphabetical order, in the file<CODE> StarComms </CODE>in the<CODE> Tutorials </CODE>directory. Alternatively, see <A HREF=BOOK3_2.HT#MARKER-9-23><I>Getting Help</I> on page 402</A>.<P>
Using the command line you can run scripts. Scripts are small programs (which you usually write in Edit) that help you control the computer. The command line is also used to issue operating system commands from BASIC.<P>
This chapter gives you an introduction to the command line. The <Cross Ref>RISC&nbsp;OS&nbsp;3 Programmer's Reference Manual<I></I> expands on all the information given in this chapter.<P>
<A NAME=HEADING1-6> </A>
<H2> Accessing the command line</H2>
<P>The following options on the Task manager icon bar menu give you access to the command line.<P>
<IMG SRC="PICS/BOO1IMA3" WIDTH=81 HEIGHT=112>
<A NAME=HEADING1-8> </A>
<H4> New task</H4>
To start a new <A NAME=MARKER-2-3> </A>task, move to the New task submenu of the <A NAME=MARKER-2-4> </A>Task menu. This produces a box into which you can type any Command Line command. If the command causes a task that is not a desktop application to run, any output from the task will be displayed in a new window; other tasks will be suspended until this task has completed. If the task is a desktop application, starting it from the New task submenu is equivalent to double-clicking on the application.
<P>
<P>
<IMG SRC="PICS/BOO1IMA4" WIDTH=351 HEIGHT=35><P>
<A NAME=HEADING2-2> </A>
<H4> * Commands</H4>
By choosing <A NAME=MARKER-2-5> </A>* Commands from the Task menu, you can enter <A NAME=MARKER-2-6> </A>Command Line Mode. A * prompt appears at the bottom of the screen, and you can enter operating system commands. To return to the desktop, press Return at a * prompt without entering any other characters on the line. Pressing <A NAME=MARKER-2-7> </A>F12 is equivalent to choosing * Commands from the Task Manager menu.<P>
<A NAME=HEADING2-4> </A>
<H4> Task window</H4>
This option allows you to use Command Line mode in a window. If you ever have to use the command line for more than a single command, this is the best way to do it. To open the window, choose <A NAME=MARKER-2-8> </A>Task window from the icon bar menu. You can have more than one Task window open. When you open a task window, you will see the * prompt. You can now enter <A NAME=MARKER-2-10> </A>operating system commands in the window.
<P><IMG SRC="PICS/BOO2IMA5" WIDTH=351 HEIGHT=146><P>
<A NAME=HEADING2-6> </A>
<H4> Exit</H4>
Clicking on <A NAME=MARKER-2-11> </A>Exit causes the <A NAME=MARKER-2-12> </A>desktop and all tasks to be closed down and replaced by the command line. You can restart the desktop by typing desktop at the * prompt, and then pressing Return. <P>
<A NAME=HEADING2-8> </A>
<H3> Command line mode</H3>
The star (*) <A NAME=MARKER-2-13> </A>prompt<A NAME=MARKER-2-14> </A> indicates that you are in command line mode and that the computer is expecting a command to be typed. Note that command line mode is sometimes called '<A NAME=MARKER-2-15> </A>Supervisor mode' (for example, when the machine starts up in command line mode).<P>
The commands in this guide are always preceded by a star. The star is provided as a prompt in command line mode, so you do not have to type it (though it does not matter if you do</B>: any extra stars are ignored). However, if you type a * Command following some other prompt (at the BASIC &gt; prompt, for example), you must precede it with a star so that the computer knows how to interpret what follows.<P>
<A NAME=HEADING2-11> </A>
<H4> Pausing on a full screen</H4>
If you are using the command line mode and you want to display a large amount of information you can set the system to pause at each full screen. Do this by typing Ctrl-N. Use the Shift key to scroll through the screenfulls. Ctrl-O removes this feature; the display no longer pauses. This does not apply to Task windows.<P>
<A NAME=HEADING2-13> </A>
<H3> Starting BASIC from the command line</H3>
Enter <A NAME=MARKER-2-16> </A>BASIC by typing <A NAME=MARKER-2-17> </A>*BASIC from the command line. The prompt will change from * to &gt;. To confirm that you are in BASIC, type in the following one-line program (must be typed using capital letters)</B>:<P>
FOR N=1 TO 20</B>: PRINT &quot;HELLO&quot;</B>: NEXT N (press Return)<P>
This will cause the word HELLO to be printed twenty times. Leave BASIC by typing QUIT or *Quit.<P>
For information on using BASIC, turn to <A HREF=BOOK3_9.HT#MARKER-9-1><I>BBC BASIC</I> on page 437</A>.<P>
The <I>BBC BASIC Reference Manual</I>, available from your supplier, is a complete reference guide for the BBC BASIC language.<P>
<A NAME=HEADING2-19> </A>
<H2> <A NAME=MARKER-9-18> </A>Using the Task window</H2>
The Task window allows you to use the command line within a window. To open a Task window, choose <A NAME=MARKER-2-19> </A><B>Task window</B> from the Task manager icon bar menu. When you open a Task window, you will see a * prompt. You can now enter commands in the window just as if you were using the command line itself. Like any other application, you can have more than one Task window at the same time.<P>
<IMG SRC="PICS/BOO2IMA6" WIDTH=351 HEIGHT=145><P>
The major advantages in entering commands in a Task window instead of at the command line prompt are</B>:<P>
<UL>

<LI>Other applications continue to run in their own windows while you run the task. (This does mean, though, that the task may run more slowly than it would using other methods of reaching the command line.)<P>

<LI>Commands that you type, plus the output (if any), appear in a conventional Edit type window, and may therefore easily be examined by scrolling up and down in the usual way. When you type into the window, or when a command produces output, the window immediately scrolls to the bottom of the text. Anything you type in is passed to the task, and has the same effect as typing whilst in command line mode. <P>
</UL>
You can change this by <B><A NAME=MARKER-2-20> </A>unlinking</B> the window</B>: in this case, anything you type in alters the contents of the window in the same way as any other Edit window, even while a task is running. Keyboard short-cuts only operate if the window is unlinked.<P>
You can also supply input to a task window by selecting some text from any text file and choosing <B>TaskInput</B> from the task window menu.<P>
You cannot use graphics in a task window. If the <B>Ignore Ctl</B> option is not chosen, the output of any commands that use graphics will appear as screen control codes.<P>
The Task window is controlled by Edit, so don't be surprised if you see the Edit icon on your icon bar.<P>
The menu for a Task window contains the following options</B>:<P>
<IMG SRC="PICS/BOO2IMA7" WIDTH=351 HEIGHT=161><P>
Kill stops and destroys the task running in the window. Reconnect starts a new task in the window, allocating memory from the Task manager's Next slot.<P>
<B>Suspend</B> temporarily halts the task running in the window.<B> Resume</B> restarts a suspended task.<P>
<B>Unlink</B> prevents the sending of typed-in characters to the task. Instead, they are processed as if the task window were a normal Edit text window.<B> Link</B> reverses the effect of Unlink.<P>
<B>TaskInput</B> reads task input from the currently selected block.<P>
<B>Ignore Ctl</B>, when selected, prevents any control characters generated by the program from being sent to the screen.<P>
<B>Edit</B> leads to the normal Edit menu. Although this makes available most of Edit's features, you cannot use facilities such as the cursor keys or keys such as Page Up and Home while you are using a task window. If you want to use Edit's keyboard short-cut features, <B>Unlink</B> the window first.<P>
<A NAME=HEADING2-35> </A>
<H4> Memory requirements</H4>
The amount of memory that the Task window uses is controlled by the size of the Next slot in the Task manager window. If you need a lot of memory for the Task manager, you can increase the Next slot size.<P>
<A NAME=HEADING2-37> </A>
<H3> Some guidelines and suggestions for using <A NAME=MARKER-2-21> </A>Task windows</H3>
To use a Task window, you will need to be familiar with command line mode. However you will also find that nearly all of the commands that affect the configuration of the desktop can also be performed using the application <B>!Boot</B> and the Task manager window <B>Tasks</B>.<P>
Here are a few commands</B>: <P>
<UL>

<LI>*Cat gives a directory listing of the current directory.<P>

<LI>*Show displays information about your computer. Press Shift to display the next screenful as necessary (or scroll a Task window).<P>

<LI>*Modules shows you which versions of modules are currently loaded.<P>

<LI>*ROMModules shows you which modules are stored in the ROM inside the computer.<P>

<LI>*Status shows you the status of the computer's CMOS memory defaults. <P>
</UL>
The command *Spool should not be used from a task window. Because its effect is to write everything that appears on the screen to the spool file, using *Spool from the desktop will produce unusable files full of screen control characters. There is, in any case, no point in using *Spool, since the output from the task appears in the window, and can be saved using Edit as normal.<P>
When you run a command in a Task window, the computer divides its time between the Task window and other activities running in the desktop. Note that some time-consuming commands may prevent access to the filing system until the command is complete.<P>
<B>Note 1</B></B>: Command line notions such as '<A NAME=MARKER-2-22> </A>current directory' become relevant when you are using Task Windows. <P>
<B>Note 2</B></B>: Using the *Copy command in a task window may lead to Filer error. Only use *Copy from the command line prompt (press F12).<P>
<B>Note 3</B></B>: Do not close a Task window while a command-line process is still running, or initiate one with little memory available, as internal errors may result.<P>
All of these commands are described in detail in the file<CODE> StarComms </CODE>in the <CODE>Tutorials </CODE>directory.<P>
<A NAME=HEADING2-51> </A>
<H2> <A NAME=MARKER-9-23> </A>Getting Help</H2>
The command <B><A NAME=MARKER-2-24> </A>*<CODE>Help</CODE></B> gives brief information about each command in the operating system. *Help keyword displays a brief explanation of the keyword and, if the keyword is a command name, the syntax of the command.<P>
If you are not sure about the name of a command</B>: <P>
*Help Commands will list all the available utility commands;<P>
*Help FileCommands will list all the commands relating to <A NAME=MARKER-2-25> </A>filing systems;<P>
*Help Modules will list the names of all currently loaded <A NAME=MARKER-2-26> </A>modules, with their version numbers and creation dates;<P>
*Help Syntax explains the format used for help messages.<P>
The usual use of *Help is to confirm that a command is appropriate for the job required, and to check on its syntax (the number, type and ordering of parameters that the command requires).<P>
When you issue the *Help command at the normal command line prompt, 'paged mode' is switched on</B>: the computer displays a screenful of text, then waits until you press Shift before moving on (in a Task window, you just scroll).<P>
The specification of the keyword can include abbreviations to allow groups of commands to be specified. For example,<P>
*help con.<P>
produces information on *Configure and *Continue. You can also use this to establish the current abbreviation for a command. Since RISC OS uses the first command it finds that matches an abbreviation, typing *Con. is equivalent to *Configure. For the *Continue command, the minimum abbreviation must distinguish it from *Configure, and is therefore *Cont. These abbreviations may change as new commands are added.<P>
<A NAME=HEADING2-63> </A>
<H2> Using the command line</H2>
You'll find many hints in the following sections</B>:<P>
<UL>

<LI><A HREF=#MARKER-9-27><I>Command line syntax</I></A>, detailing the syntax you need to use within the command line.<P>

<LI><A HREF=#MARKER-9-37><I>System devices</I></A>, giving you a summary of useful system devices you can use.<P>

<LI><A HREF=#MARKER-9-55><I>System variables</I></A>, explaining how variables are used by the operating system.<P>

<LI><A HREF=#MARKER-9-74><I>Command and application options and other variables</I></A>, explaining how to use variable options with commands and applications.<P>

<LI><A HREF=#MARKER-9-81><I>Command scripts</I></A>, showing you how to write Command and Obey files to control the computer.<P>

<LI><A HREF=#MARKER-9-93><I>Using GS formats in scripts</I></A>, showing the formats used to handle control characters.<P>
</UL>
<A NAME=HEADING2-71> </A>
<H2> <A NAME=MARKER-9-27> </A>Command line syntax</H2>
The interface to the command line is built into the RISC OS operating system and processes valid commands sent as text strings. The text string is normally terminated by Return.<P>
The <A NAME=MARKER-2-28> </A>syntax of each command in the following chapters is described in a standard way, with examples of its use where these are helpful. The symbols used in syntax descriptions are</B>:<P>
<CODE>&lt;value&gt;</CODE>  indicate that an actual value must be substituted. For example, <CODE>&lt;filename&gt; </CODE>means that you must supply an actual filename.<P>
[...]  indicate that the item enclosed in the square brackets is optional.<P>
|  indicates alternatives. For example, 0 | 1 means that the value 0 or 1 must be supplied.<P>
<A NAME=HEADING2-77> </A>
<H3> What are parameters?</H3>
RISC OS commands are sometimes followed by one or <A NAME=MARKER-2-29> </A>more parameters which tell the computer how you want the command to be modified.<P>
In the following descriptions, the parameters are in italics. You can leave spaces only <B>between</B> parameters, since otherwise the operating system cannot tell where you want one parameter to end and the next to begin.<P>
Command line parameters may be optional</B>: in this case they are shown in the syntax within square brackets. Often, when a parameter is specified as optional, the operating system will supply a <A NAME=MARKER-2-30> </A>default value; the value of this is specified for each command.<P>
<A NAME=HEADING2-81> </A>
<H3> Numeric parameters</H3>
Some commands have one or more numeric <A NAME=MARKER-2-31> </A>parameters. These are interpreted as decimal by default (unless the description of the command specifies otherwise), but it is possible to express them in any base by prefacing the parameter itself with the base followed by an underscore, as in the following examples</B>:<P>
*Eval 2_1010101 : returns the integer value of the argument, 85.<P>
*Eval 16_FFF : similarly, returns the value 4095.<P>
An alternative form for hexadecimal uses the &amp; sign to signify base 16</B>:<P>
<CODE>*Eval &amp;FFF</CODE><P>
Decimal and hexadecimal are likely to be the most useful bases.<P>
<A NAME=HEADING2-88> </A>
<H3> Wildcards</H3>
It is useful in many command line operations to specify objects using '<A NAME=MARKER-2-32> </A>wildcards'. There are two wildcards</B>:<P>
*   stands for zero or more characters<P>#   stands for a single character<P>
Examples:<P> he*  would stand for he, help, hello, or hencoop<P> he*p  would stand for help or hencoop<P> he##  would stand for help, hens or head, but not hen or health<P>
<A NAME=HEADING2-92> </A>
<H3> Checks on the command</H3>
Before a command is executed, the command line interface carries out a certain amount of pre-processing on the line</B>:<P>
<UL>

<LI>Stars and spaces are skipped at the start of a command. The command line prompt includes a star, so there is no need to type one, but it doesn't matter if you do. <P>

<LI>Comment lines are ignored. <A NAME=MARKER-2-33> </A>Comments are introduced by typing '|' as the first non-space character on a line.<P>

<LI>Command length is checked. Command lines must be less than or equal to 256 characters, including the terminating character. Lines which are too long produce an error message.<P>

<LI>Redirection (output to a file, or input from a file) is checked.<P>

<LI>Single-character prefixes are checked, such as '/', equivalent to Run, or '%' which instructs the command line interface to skip alias checking.<P>

<LI>Alias commands are checked. (<A HREF=#MARKER-9-55><I>System variables</I> on page 407</A> gives more information on the use of aliases.)<P>

<LI>The command is passed for execution. Commands offered to the command line interface are looked up in the OS table, passed to any other modules, the filing system manager, and finally *Run as a file of the name given, in an attempt to execute the command.<P>
</UL>
Full details of this checking are given in the RISC OS Programmer's Reference Manual.<P>
<A NAME=HEADING2-102> </A>
<H3> File redirection</H3>
A powerful feature of RISC OS is the ability to redirect input or output streams (or both) for the duration of the command. By default, output is directed to the screen, but it may be convenient to redirect the output stream to a file so that you can examine it later in more detail, or process it further.<P>
The format of a redirection is</B>:<P>
<CODE>&lt;command&gt; { &lt;redirection spec&gt; }</CODE><P>
where the <CODE>&lt;redirection spec&gt; </CODE>is at least one of</B>:<P>
&gt; <CODE>&lt;filename&gt;</CODE> : output goes to <CODE>filename</CODE><P>  &lt; <CODE>&lt;filename</CODE>   : input read from <CODE>filename</CODE><P>  &gt;&gt; <CODE>&lt;filename</CODE>   : output is appended to <CODE>filename</CODE>. <P>
Note the following</B>:<P>
<UL>

<LI>Spaces in the redirection specification are significant.<P>

<LI>The braces are a literal part of the redirection format.<P>

<LI>There must be a single space between each pair of elements for it to be recognised as a redirection.<P>
</UL>
Examples<P>
*Cat  { &gt; mycat }<P>
This sends a list of the contents in the current directory to a file called <CODE>mycat</CODE>.<P>
*Help Cat { &gt; CatHelp }<P>
This sends all the help information on the * command Cat, (elicited by the command <CODE>*Help Cat</CODE>) to a file called CatHelp.<P>
<A NAME=HEADING2-117> </A>
<H2> <A NAME=MARKER-0-36> </A><A NAME=MARKER-9-37> </A>System devices</H2>
<A NAME=MARKER-2-38> </A>The operating system contains a number of useful <A NAME=MARKER-2-39> </A>system devices, which behave like files in some ways. You can use them anywhere you would normally use a file name as a source of input, or as a destination for output. These include</B>:<P>
<A NAME=HEADING2-119> </A>
<H3> System devices suitable for input</H3>
<A NAME=MARKER-2-40> </A>kbd</B>:  the keyboard, reading a line at a time (this allows editing using Delete, Ctrl-U, and other keys) <P>
<A NAME=MARKER-2-41> </A>rawkbd</B>:  the keyboard, reading a character at a time<P>
serial</B>:  the serial port<P>
<A NAME=MARKER-2-43> </A>parallel</B>:  the parallel port<P>
<A NAME=MARKER-2-44> </A>null</B>:  the 'null device', which effectively gives no input<P>
<A NAME=HEADING2-125> </A>
<H3> System devices suitable for output</H3>
<A NAME=MARKER-2-45> </A>vdu</B>:  the screen, using GSRead format (see <A HREF=#MARKER-9-93>page 419</A>)<P>
<A NAME=MARKER-2-46> </A>rawvdu</B>:  the screen, via the VDU drivers <P>
<A NAME=MARKER-2-47> </A>serial</B>:  the serial port<P>
<A NAME=MARKER-2-48> </A>parallel</B>:  the parallel port<P>
<A NAME=MARKER-2-49> </A>printer</B>:  the currently configured printer<P>
<A NAME=MARKER-2-50> </A>netprint</B>:  the currently configured network printer<P>
null</B>:  the 'null device', which swallows all output<P>
These system devices can be useful with commands such as *Copy, and the redirection operators (&gt; and &lt;)</B>:<P>
<CODE>*Copy myfile printer</B>:</CODE>    Send <CODE>myfile</CODE> to the printer<P>
*Cat { &gt; printer</B>: }    List the files in the current directory to the printer<P>
*Cat netprint</B>:    Display the currently selected network printer and a list of available network printers.<P>
The system device null</B>: is useful to suppress unwanted output from a command script or program</B>:<P>
*myprogram { &gt; <A NAME=MARKER-2-51> </A>null</B>: }    Runs myprogram with no output<P>
The most useful <A NAME=MARKER-2-52> </A>system devices for the general user are likely to be printer</B>: and <A NAME=MARKER-2-53> </A>netprint</B>:<P>
<A NAME=HEADING2-140> </A>
<H2> !Run and !Boot files within applications</H2>
If you Shift-double-click on an application you'll see a !Run file (it has the file type Obey). An application's !Run file is obeyed whenever you start the application. This file sets up the application's environment, loads any resources it requires and then starts the application code (often called !Runimage).<P>
The application also contains a !Boot file, this is used when the application is first 'seen'. This occurs when the directory containing the application is displayed on the screen. The !Boot file sets up the application sprite used in the directory display.<P>
<A NAME=HEADING2-143> </A>
<H4> Using !Draw as an example</H4>
Most !Boot and !Run files have lines containing Set commands. For example, !Draw sets up variables that include a RunType and a PrintType for the normal DrawFile file type &amp;AFF. <P>
Draw also sets up a variable called Draw$Dir which sets up the computer to remember where the Draw application is on the computer. It uses another variable called Obey$Dir, this contains the path of the directory in which the current obey file is running.<P>
You will find all these variables explained in greater detail later in this chapter.<P>
<A NAME=HEADING2-147> </A>
<H3> What is a module?</H3>
A <A NAME=MARKER-2-54> </A>module is a piece of software that is loaded into memory. A section of memory is reserved for use by modules and is known as the RMA (relocatable module area). <P>
If you look at the !Run file of !Draw you'll see some RMEnsure commands are used these particular commands make RISC OS check the named module is present in the RMA.<P>
<A NAME=HEADING2-150> </A>
<H2> <A NAME=MARKER-9-55> </A><A NAME=MARKER-0-56> </A>System variables</H2>
<A NAME=HEADING2-151> </A>
<H3> Introducing system variables</H3>
<A NAME=MARKER-2-57> </A>System <A NAME=MARKER-2-58> </A>variables are used by RISC OS to store settings that control the behaviour of the computer. For example, they store how you like the time and date to be printed, how you want the *Copy command to work, and what prompt you like.<P>
However, unlike configuration features, your settings for system variables are not preserved when you switch the computer off or reset it. When you do this, the computer always goes back to the default values for the standard set of system variables, but if you have a Desktop boot file loaded, your favourite settings will be kept. You can see these default values by typing *Show just after switching on your computer.<P>
In addition to RISC OS system variables, applications commonly use variables of their own, to control their default behaviour. For example, Edit uses variables to store your choices of display font, background colour and so on. Where there are such variables, they are listed in <A HREF=BOOK3_6.HT#MARKER-9-1><I>Configuring applications</I> on page 427</A>. Some suggestions for using them are also included later in this chapter.<P>
<A NAME=HEADING2-155> </A>
<H4> Setting variables in a Boot file</H4>
If the default values are not the ones you want, you can change them using the *Set command. The computer does not remember system variables between sessions, so if you want different default values you must change the variable each time you use your computer. Rather than typing them each time by hand, you can include the *Set commands in a <A NAME=MARKER-2-59> </A>boot file (a file that is run each time you use the computer).<P>
However, although you could create such a boot file 'by hand', typing it in Edit, a much easier way is to use the Task manager's Desktop boot facility, described in <A HREF="../BOOKB/BOOK_5.HTM#HEADING5-0"><I>Customising the desktop start-up procedure</I> on page 51</A>. You will then not need to understand anything about system variables as such, since you can simply set up the desktop the way you want it and make a Desktop boot file. Creating your own boot file by editing one created by the Task manager is the easiest way to start.<P>
<A NAME=HEADING2-158> </A>
<H4> Referring to variables</H4>
Each variable is accessed by its name, which can contain any character which is neither a space nor a control character. As with filenames, the case of characters is remembered, but is ignored when the names are looked up.<P>
<A NAME=HEADING2-160> </A>
<H4> What are variables for?</H4>
RISC OS uses the values of variables to make the desktop work. When you double-click on a file (not an application), RISC OS looks up the alias for RUNning that file type in the variable list. If it finds a match, the command stored in the variable (for example RMLoad %*0) is executed, substituting the name of the file in place of the marker %*0; otherwise an error box is displayed. <P>
In general, files which are displayed as white squares (they have no file type icon) will give this error if you try to use them in this way.<P>
<A NAME=HEADING2-163> </A>
<H3> Application variables</H3>
<A NAME=MARKER-2-60> </A>There are many different system variables provided and used by RISC OS, as well as some which may be added by applications. You can see them all by typing *Show (use Shift to display each successive screenful).<P>
The following section gives standard names used for some of the variables that are connected to a particular application.<P>
<A NAME=HEADING2-166> </A>
<H4> App$Dir</H4>
An <I>App</I>$Dir variable gives the full pathname of the directory that holds the application <I>App</I>. This is typically set in the application's !Run file by the line</B>:<P>
Set <CODE>App</CODE>$Dir &lt;Obey$Dir&gt;<P>
<A NAME=HEADING2-169> </A>
<H4> App$Path</H4>
An <I>App</I>$Path variable gives the full pathname of the directory that holds the application <I>App</I>. An <I>App</I>$Path variable differs from an <I>App</I>$Dir variable in two important respects</B>:<P>
<UL>

<LI>The pathname includes a trailing '.'<P>

<LI>The variable may hold a set of pathnames, separated by commas.<P>
</UL>
It's common to use an <I>App</I>$Dir variable rather than an <I>App</I>$Path variable, but there may be times when you need the latter.<P>
An <I>App</I>$Path variable might, for example, be set in the application's !Run file by the line</B>:<P>
Set <CODE>App</CODE>$Path &lt;Obey$Dir&gt;.,%.<CODE>App</CODE>.<P>
if the application held further resources in the subdirectory <CODE>App</CODE> of the library.<P>
<A NAME=HEADING2-177> </A>
<H4> <A NAME=MARKER-2-61> </A>App$Options</H4>
An <I>App</I>$Options variable holds the start-up options of the application <I>App</I></B>:<P>
<UL>

<LI>An option that can be either on or off should consist of a single character, followed by the character '+' or '<UNDERLINE>-</UNDERLINE>' (e.g. <CODE>M+</CODE> or <CODE>S-</CODE>).<P>

<LI>Other options should consist of a single character, followed by a number (e.g. <CODE>P4</CODE> or <CODE>F54</CODE>).<P>

<LI>Options should be separated by spaces; so a complete string might be <CODE>F54 M+ P4 S-</CODE>.<P>
</UL>
This variable is typically used to save the state of an application to a Desktop boot file, upon receipt of a desktop save message. A typical line output to the boot file might be</B>:<P>
Set <CODE>App</CODE>$Options F54 M+ P4 S-<P>
An application should only save those options that differ from the default, so there will be no line at all if the application is in its default state.<P>
<A NAME=HEADING2-185> </A>
<H4> App$PrintFile</H4>
An <I>App</I>$PrintFile variable holds the name of the file or system device to which the application <I>App</I> prints. Typically this will be <CODE>printer</B>:</CODE>, and would be set in your application's !Run file as follows</B>:<P>
Set <CODE>App</CODE>$PrintFile printer</B>:<P>
<A NAME=HEADING2-188> </A>
<H3> <A NAME=MARKER-9-62> </A>Changing and adding commands</H3>
<A NAME=HEADING2-189> </A>
<H4> Alias$Command</H4>
An Alias$<I>Command</I> variable is used to define a new <A NAME=MARKER-2-63> </A>command named <I>Command</I>. For example</B>:<P>
Set Alias$Mode echo |&lt;22&gt;|&lt;%0&gt;<P>
By using the name of an existing command, you can change how it works.<P>
<A NAME=HEADING2-193> </A>
<H3> Using file types</H3>
<A NAME=HEADING2-194> </A>
<H4> File$Type_XXX</H4>
A File$Type_<I>XXX</I> variable holds the textual name for a file having the hexadecimal file type <I>XXX</I>. It is typically set in the !Boot file of an application that provides and edits that file type. For example</B>:<P>
Set File$Type_<CODE>XXX</CODE> <CODE>&lt;TypeName&gt;</CODE><P>
The reason the !Boot file is used rather than the !Run file is so that the file type can be converted to text from the moment its 'parent' application is first seen, rather than only from when it is run.<P>
<A NAME=HEADING2-198> </A>
<H4> Alias$@LoadType_XXX, Alias$@PrintType_XXX and Alias$@RunType_XXX</H4>
These variables set the commands used respectively to load, print and run a file of hexadecimal type <I>XXX. </I>They are typically set in the !Boot file of an application that provides and edits that file type. For example</B>:<P>
Set Alias$@PrintType_<CODE>XXX</CODE> /&lt;Obey$Dir&gt; -Print <P> Set Alias$@RunType_<CODE>XXX</CODE> /&lt;Obey$Dir&gt; <P>
<B>Note</B></B>: The above lines <B>both have a trailing space</B> (invisible in print!).<P>
The reason the !Boot file is used rather than the !Run file is so that files of the given type can be loaded, printed and run from the moment their 'parent' application is first seen, rather than only from when it is run.<P>
<A NAME=HEADING2-203> </A>
<H3> Setting the command line prompt</H3>
<A NAME=HEADING2-204> </A>
<H4> <A NAME=MARKER-9-64> </A>CLI$Prompt</H4>
The CLI$Prompt variable sets the command line interpreter prompt. By default this is '*'. One common way to change this is so that the system time is displayed as a prompt. For example</B>:<P>
SetMacro CLI$Prompt &lt;Sys$Time&gt; *<P>
This is set as a macro so that the system time is evaluated each time the prompt is displayed. <P>
There's more on this in <A HREF=#MARKER-9-77><I>Creating your own command line prompt</I> on page 413</A>.<P>
<A NAME=HEADING2-209> </A>
<H3> Configuring RISC OS commands</H3>
<A NAME=HEADING2-210> </A>
<H4> Copy$Options, Count$Options and Wipe$Options</H4>
<A NAME=MARKER-2-66> </A>These variables set the behaviour of the *Copy, *Count and *Wipe commands. For a full description type <CODE>*Help command </CODE>at the command line.<P>
<A NAME=HEADING2-212> </A>
<H3> System path variables</H3>
<A NAME=HEADING2-213> </A>
<H4> File$Path and Run$Path</H4>
These variables control where files are searched for during read operations or execute operations. They are both <A NAME=MARKER-2-67> </A>path variables, which means that - in common with other path variables - they consist of a comma-separated list of full pathnames, each of which has a trailing '.'.<P>
If you wish to add a pathname to one of these variables, you must ensure that you append it once, and once only. For example, to add the 'bin' subdirectory of an application to Run$Path, you could use the following lines in the application's !Boot file</B>:<P>
<PRE>
If &quot;&lt;<CODE>App</CODE>$Path&gt;&quot; = &quot;&quot; then Set Run$Path &lt;Run$Path&gt;,&lt;Obey$Dir&gt;.bin.
Set <CODE>App</CODE>$Path &lt;Obey$Dir&gt;.
</PRE>
<A NAME=HEADING2-217> </A>
<H3> Obey files</H3>
<A NAME=HEADING2-218> </A>
<H4> Obey$Dir</H4>
The Obey$Dir variable is set to the directory from which an Obey file is being run, and may be used by commands within that Obey file.<P>
<A NAME=HEADING2-220> </A>
<H3> <A NAME=MARKER-9-69> </A>Time and date</H3>
<A NAME=HEADING2-221> </A>
<H4> <A NAME=MARKER-9-70> </A>Sys$Time, Sys$Date and Sys$Year</H4>
These variables are code variables that are evaluated at the time of their use to give, respectively, the current system time, date and year. <P>
<A NAME=HEADING2-223> </A>
<H4> Sys$DateFormat</H4>
The Sys$DateFormat variable sets the format in which the date is presented by some commands.<P>
<A NAME=HEADING2-225> </A>
<H3> <A NAME=MARKER-2-71> </A>!System and <A NAME=MARKER-2-72> </A>!Scrap</H3>
<A NAME=HEADING2-226> </A>
<H4> System$Dir and System$Path</H4>
These variables give the full pathname of the System application. They have the same value, except that System$Path has a trailing '.', whereas System$Dir does not. You must not change these values.<P>
(There are two versions of this pathname for compatibility with some old applications). !System and !Scrap are contained in the !Boot application.<P>
<A NAME=HEADING2-229> </A>
<H4> Wimp$Scrap</H4>
The Wimp$Scrap variable gives the full pathname of the Wimp scrap file used by the file transfer protocol. You must not use this variable for any other purpose, nor change its value.<P>
<A NAME=HEADING2-231> </A>
<H4> <A NAME=MARKER-9-73> </A>Wimp$ScrapDir</H4>
The Wimp$ScrapDir variable gives the full pathname of a scrap directory within the Scrap application, which you may use to store temporary files. You must not use this variable for any other purpose, nor change its value.<P>
<A NAME=HEADING2-233> </A>
<H3> The desktop</H3>
<A NAME=HEADING2-234> </A>
<H4> Wimp$State</H4>
The Wimp$State variable shows the current state of the Wimp. If the desktop is running, it has the value 'desktop'; otherwise it has the value 'commands'.<P>
<A NAME=HEADING2-236> </A>
<H2> <A NAME=MARKER-9-74> </A>Command and application options and other variables</H2>
Some commands, such as *Copy and *Wipe, can operate in a variety of ways. For example, you can effectively turn <A NAME=MARKER-2-17> </A>*Copy into a Move command by setting the D(elete) option, which deletes the source file after copying it to another directory or filing system. You would do this by typing<P>
*Set Copy$Options &lt;Copy$Options&gt; D<P>
at the command line prompt. These options are described in the entries for each command in the file<CODE> StarComms </CODE>in the<CODE> Tutorials </CODE>directory.<P>
Several <A NAME=MARKER-2-76> </A>applications, such as Edit, Draw, Alarm and Paint, also use system variables to record, for example, whether you want the Paint colours window to appear automatically when you open a sprite window, or whether you want the toolbox to be displayed by default in Draw. Such variables use the format App$Options, where App is the name of the application in question. These variables will only be listed in the computer's response to the *Show command if you have changed them from their default values.<P>
In addition to 'options', applications may use other variables for a variety of purposes. For example, Acorn Desktop Publisher needs to know where its 'Work' directory is. It will find this out when the Work directory has been displayed on the screen, and it assigns the directory's pathname to the variable dtp$WorkDir. To avoid having to carry out this action each time you use the application, you can put a *Set command identifying the directory in your boot file, for example</B>:<P>
*Set dtp$WorkDir &lt;Obey$Dir&gt;.WorkDir<P>
<A NAME=HEADING2-243> </A>
<H4> <A NAME=MARKER-9-77> </A>Creating your own command line prompt</H4>
You can use a system variable to change the operating system <A NAME=MARKER-2-78> </A>prompt - normally * <A NAME=MARKER-2-27> </A>- by setting the variable CLI$Prompt to (for example) the character #</B>:<P>
*Set CLI$Prompt #<P>
You can also set one variable to the value of another</B>:<P>
*Set CLI$Prompt &lt;Sys$Time&gt;<P>
This sets the prompt to the system time, but only does so once, when the command is given. However, it would clearly be more useful if the prompt always showed the current time. To do this, change CLI$Prompt from a variable into a <A NAME=MARKER-2-80> </A>macro. A macro is similar to a variable, but is evaluated every time it is used, instead of just once when it is set. Therefore, type the following</B>:<P>
*SetMacro CLI$Prompt &lt;Sys$Time&gt; *<P>
Each time Return is pressed at the command line prompt a new prompt is given (unless you have not typed anything since the last Return; you will then be returned to the desktop); the current time is worked out and displayed, followed by a space character and an asterisk</B>:<P>
12</B>:59</B>:06 *<P> 12</B>:59</B>:07 *<P> 12</B>:59</B>:08 *<P>
<A NAME=HEADING2-252> </A>
<H3> Other uses for system variables</H3>
The names of commands may be changed using the *Set command with variables whose name starts Alias$... This allows you to add new commands, to change the meaning of existing commands, to combine commands together, and to add your own parameters to a command.<P>
Programmers can use system variables to pass values between programs. One program can create and write to a variable which another program can then read. Such variables should have names starting App$, where App is your program; this avoids problems caused by different programs using the same system variable names. <P>
<A NAME=HEADING2-255> </A>
<H2> <A NAME=MARKER-9-81> </A>Command scripts</H2>
<A NAME=MARKER-2-50> </A>Command scripts are files of commands that you would normally type in at the command line prompt. There are two main uses for such files</B>:<P>
<UL>

<LI>To set up the computer to the state you want, either when you switch on or when you start an application. <P>
</UL>
This type of command script is commonly known as a <A NAME=MARKER-2-83> </A>boot file, because it is used to 'boot up' the computer. You can create such a file without needing to know anything about the command line, using the Desktop boot facility in the Task manager, described in <A HREF="../BOOKB/BOOK_5.HTM#HEADING5-0"><I>Customising the desktop start-up procedure</I> on page 51</A>. <P>
<UL>

<LI>To save typing in a set of commands you find yourself using frequently. <P>
</UL>
For example, if you often want to display information about a file and then print it, you can combine the commands *FileInfo and *Type into a command script.<P>
You may find using an Alias$... variable to be better for the second case. The main advantage of using variables rather than command files is that they are held in memory and so are quicker in execution; however, they are only really suitable for short commands. If you use variables you will probably still want to use a command file to set them up when you switch on. <P>
<A NAME=HEADING2-262> </A>
<H3> Command and Obey file types</H3>
There are two types of file you can use for command scripts</B>: Command files, and <A NAME=MARKER-2-85> </A>Obey files. The differences between these two file types are</B>:<P>
<UL>

<LI>An Obey file is always passed to the command line interpreter, whereas a Command file is passed to the current input. <P>

<LI>An Obey file is read directly, whereas a Command file is treated as if it were typed at the keyboard (and hence usually appears on the screen).<P>

<LI>An Obey file sets the system variable Obey$Dir to the directory it is in.<P>

<LI>An Obey file can have <A NAME=MARKER-2-86> </A>parameters passed to it.<P>
</UL>
The differences between Command and Obey files is explained in an example on <A HREF=#MARKER-9-91>page 417</A>.<P>
Additionally there are the TaskExec and TaskObey file types. These are very similar to Command and Obey files. Their main advantage is that they multi-task under the desktop</B>:<P>
<UL>

<LI>A TaskExec file is *Exec'd in a task window.<P>

<LI>A TaskObey file is *Obey'd, opening a task window only if needed for I/O. It quits the window when finished. <P>
</UL>
It is recommended that you don't use *Copy and related filer commands in TaskObey files - use Filer_Action instead.<P>
<A NAME=HEADING2-273> </A>
<H3> <A NAME=MARKER-9-87> </A>Creating a command script</H3>
A command script can be created using any text or word processor. If you created the file using Edit, you should set the file's type by pressing Menu over the Edit icon on the icon bar and choosing the desired file type, such as Command or Obey. <P>
When you save the file you should consider in which directory you will save it. By default, files are looked for first in the current directory, then in the library. Therefore, if you want to avoid having to type the full pathname of the file every time you run it you should save it in one of the following</B>:<P>
<UL>

<LI>The directory from which the command script will be run (typically your root directory, or an application directory).<P>

<LI>The library. The library is typically $.Library, but may be $.ArthurLib on a network.<P>
</UL>
<A NAME=HEADING2-278> </A>
<H3> Running the script</H3>
Provided that you have set the file type to Command or Obey, the file can then be run in the same ways as any other file, by<P>
<UL>

<LI>typing its name at the * prompt<P>

<LI>typing its name preceded by a * at any other prompt (some applications may not support this)<P>

<LI>double-clicking on its icon in a directory display.<P>
</UL>
The same restrictions apply as with any other file. If the file is not in either your current directory or the library, it will not be found if you just give the filename; you must give its full pathname. This assumes you have not changed the value of the system variable <A NAME=MARKER-2-88> </A>Run$Path.<P>
<A NAME=HEADING2-284> </A>
<H3> Making a script run automatically</H3>
<A NAME=MARKER-2-89> </A>You can make scripts run automatically<P>
<UL>

<LI>from the network when you first log on<P>

<LI>from a disc when you first switch the computer on<P>

<LI>from an application directory when the application is run.<P>
</UL>
You'll find information on how to do this in <A HREF="../BOOKB/BOOK_5.HTM#HEADING5-0"><I>Customising the desktop start-up procedure</I> on page 51</A>.<P>
<A NAME=HEADING2-290> </A>
<H3> Using parameters</H3>
An Obey file - but not a Command file - can have parameters passed to it, which can then be used by the command script. The first parameter is referred to as %0, the second as %1, and so on. You can refer to all the parameters after a particular one by putting a * after the %, so %*1 would refer to all the parameters from the second one onwards.<P>
These parameters are substituted before the line is passed to the command line interpreter. Thus if an Obey file called Display contained</B>:<P>
FileInfo %0 Type %0<P>
then the command *Display MyFile would do this</B>:<P>
FileInfo MyFile<P>Type MyFile<P>
Sometimes you do not want parameter substitution. For example, suppose you wish to include a *Set Alias$ command in your file, such as</B>:<P>
Set <A NAME=MARKER-2-90> </A>Alias$Mode echo |&lt;22&gt;|&lt;%0&gt; &lt;Command&gt;<P>
The effect of this is to create a new command 'Mode'. If you include the *Set Alias command in an Obey file, when you run the file the %0 will be replaced by the first parameter passed to the file. To prevent the substitution you need to change the % to %%</B>:<P>
Set Alias$Mode echo |&lt;22&gt;|&lt;%%0&gt; &lt;Command&gt;<P>
Now when the file is run, the '%%0' is changed to '%0'. No other substitution occurs at this stage, and the desired command is issued.<P>
<A NAME=HEADING2-301> </A>
<H3> <A NAME=MARKER-9-91> </A>Examples</H3>
These example files illustrate some of the differences between Command and Obey files</B>:<P>
<A NAME=HEADING2-303> </A>
<H4> Example 1</H4>
*BASIC<P>AUTO<P>FOR J= 1 TO 10  <P>   PRINT &quot;Hello&quot;<P>NEXT J<P> END<P>
If this is a command file, it will enter the BASIC interpreter, and input the file shown. The command script will end with the BASIC interpreter waiting for another line of input. You can then press Esc to get a prompt, type RUN to run the program, and then type QUIT to leave BASIC. This script shows how a command file is passed to the input, and can change what is accepting its input (in this case to the BASIC interpreter). <P>
On the other hand, if this is an Obey file it will be passed to the command line interpreter, and an attempt will be made to run these commands</B>:<P>
*BASIC<P>*AUTO<P>*FOR I = 1 TO 10<P>*  PRINT &quot;Hello&quot;<P>*NEXT I <P>*END<P>
Only the first command is valid, as an Obey file all this does is to leave you in the BASIC interpreter. Type QUIT to leave BASIC; you will then get an error message saying File 'AUTO' not found, generated by the second line in the file.<P>
<A NAME=HEADING2-309> </A>
<H4> Example 2</H4>
The next example illustrates how control characters are handled</B>:<P>echo &lt;7&gt;<P>echo |&lt;7&gt;<P>
The control characters are represented in <A NAME=MARKER-2-92> </A>GSTrans format (see <A HREF=#MARKER-9-93><I>Using GS formats in scripts</I> on page 419</A>). These are not interpreted until the echo command is run, and are only interpreted then because echo expects GSTrans format. <P>
The first line sends an ASCII 7 to the VDU drivers, sounding a beep. In the second line, the | preceding the &lt; changes it from the start of a GSTrans sequence to just representing the character &lt;, so the overall effect is</B>:<P>
<CODE>echo &lt;7&gt;</CODE>   : send ASCII 7 to VDU drivers - beeps <CODE><P>echo |&lt;7&gt; </CODE>  : send &lt;7&gt; to the screen<P>
<A NAME=HEADING2-315> </A>
<H4> Example 3</H4>
The last examples are a Command file</B>:<P>
<CODE>*Set Alias$more %echo |&lt;14&gt;|m %type -tabexpand %*0|m %echo |&lt;15&gt;</CODE><P>
and an Obey file that has the same effect</B>:<P>
Set Alias$more %echo |&lt;14&gt;|m %type -tabexpand %%*0|m %echo |&lt;15&gt;<P>
The only differences between the two examples are that the Command file has a preceding * added, to ensure that the command is passed to the command line interpreter, and that the Obey file has the %*0 changed to %%*0 to delay the substitution of parameters. <P>
The file creates a new command<CODE> </CODE>more by setting the variable Alias$more.<P>
<UL>

<LI>The % characters that precede echo and type ensure that the actual commands are used, rather than an aliased version of them. <P>

<LI>The sequence |m represents a carriage return in GSTrans format (see <A HREF=#MARKER-9-93><I>Using GS formats in scripts</I></A> below). It is used to separate the commands, just as Return would if you were typing the commands. <P>

<LI>The two echo commands turn scroll mode on, then off, by sending the control characters ASCII 14 and 15 respectively to the VDU drivers. <P>

<LI>The | before each &lt; prevents the control characters from being interpreted until the aliased command more is run.<P>
</UL>
The command turns scroll mode on, types a file to the screen expanding tabs as it does so, and then turns scroll mode off.<P>
<A NAME=HEADING2-327> </A>
<H2> <A NAME=MARKER-9-93> </A>Using GS formats in scripts</H2>
The GSTrans and GSRead formats are used by a number of commands that need to be able to handle control characters, and characters whose top bit is set. They enable you to use these characters, which would otherwise cause unpredictable output from your monitor or printer, and which would be difficult to enter directly from the keyboard. The two formats are identical.<P>
The GSRead or GSTrans format is used by some commands to read characters that you type in. The characters are interpreted using the following conventions</B>:<P>
<UL>

<LI>A character preceded by a | is converted into the relevant control code</B>: |C would become ASCII 3 (which is Ctrl C).<P>

<LI>An integer within angle brackets is converted into the equivalent ASCII code</B>: &lt;7&gt; would become ASCII 7.<P>

<LI>A variable name within angle brackets is replaced by the value held in the variable, or is ignored if the variable does not exist.<P>

<LI>All other characters are unchanged.<P>
</UL>
A full list of ASCII codes and how to obtain them is given below. Of course, any ASCII code may be obtained by enclosing it in angle brackets as described above, and this may be easier to remember than the symbol encoding.
<P>
<P>
<B>ASCII code: Symbols used:</B><P><UL>
<LI><B>0</B>: |@ 
<LI><B>1 - 26</B>: |letter e.g. |A (or |a) = ASCII 1
<LI><B>27</B>: |[ or |{ 
<LI><B>28</B>: |\
<LI><B>29</B>: |] or  |}
<LI><B>30</B>: |^ or |~ 
<LI><B>31</B>: |_ or |' 
<LI><B>32 - 126</B>: keyboard character, except for: &quot;, |&quot;, |</B>: ||, &lt;</B>: |&lt;
<LI><B>127</B>: |?
<LI><B>128 - 255</B>: |!coded-symbol e.g. ASCII 128 = |!|@; ASCII 129 = |!|A etc </UL>
<P>
You must use |&lt; to prevent the &lt; from being interpreted as the start of a number or variable name enclosed in angled brackets.<P>
<A NAME=MARKER-2-94> </A>To include leading spaces in a definition, the string must be in double quotation marks, &quot;, which are not included in the definition. To include a literal  &quot; character in the string, use |&quot; or &quot;&quot;.<A NAME=MARKER-2-95> </A><P>


<HR>
<ADDRESS>RISC OS 3.7 User Guide - 20 JAN 1997</ADDRESS>
<A HREF="BOOK3_3.HT"> <IMG ALIGN=BOTTOM SRC="next" WIDTH=69 HEIGHT=24></A> <A HREF="../BOOK2AB/E_18.HTM"> <IMG ALIGN=BOTTOM SRC="prev" WIDTH=69 HEIGHT=24> </A> <A HREF="../BOOKB/USERGUIDE"> <IMG ALIGN=BOTTOM SRC="top" WIDTH=69 HEIGHT=24></A> <A HREF="../BOOKB/TOC.HTM"> <IMG ALIGN=BOTTOM SRC="content" WIDTH=69 HEIGHT=24></A>  <A HREF="../INDEX/MAIN.HTM"><IMG ALIGN=BOTTOM SRC="index" WIDTH=69 HEIGHT=24></A><P>
</BODY>
</HTML> 